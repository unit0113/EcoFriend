"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/picomatch@2.3.1";
exports.ids = ["vendor-chunks/picomatch@2.3.1"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = __webpack_require__(/*! ./lib/picomatch */ \"(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vcGljb21hdGNoQDIuMy4xL25vZGVfbW9kdWxlcy9waWNvbWF0Y2gvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsaUpBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGFpbHdpbmR1aS1zdHVkaW8vLi9ub2RlX21vZHVsZXMvLnBucG0vcGljb21hdGNoQDIuMy4xL25vZGVfbW9kdWxlcy9waWNvbWF0Y2gvaW5kZXguanM/Y2Y0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvcGljb21hdGNoJyk7XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst path = __webpack_require__(/*! path */ \"path\");\nconst WIN_SLASH = \"\\\\\\\\/\";\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n/**\n * Posix glob regex\n */ const DOT_LITERAL = \"\\\\.\";\nconst PLUS_LITERAL = \"\\\\+\";\nconst QMARK_LITERAL = \"\\\\?\";\nconst SLASH_LITERAL = \"\\\\/\";\nconst ONE_CHAR = \"(?=.)\";\nconst QMARK = \"[^/]\";\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\nconst POSIX_CHARS = {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    QMARK_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    QMARK,\n    END_ANCHOR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n};\n/**\n * Windows glob regex\n */ const WINDOWS_CHARS = {\n    ...POSIX_CHARS,\n    SLASH_LITERAL: `[${WIN_SLASH}]`,\n    QMARK: WIN_NO_SLASH,\n    STAR: `${WIN_NO_SLASH}*?`,\n    DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n    NO_DOT: `(?!${DOT_LITERAL})`,\n    NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n    NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n    NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n    QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n    START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n    END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n};\n/**\n * POSIX Bracket Regex\n */ const POSIX_REGEX_SOURCE = {\n    alnum: \"a-zA-Z0-9\",\n    alpha: \"a-zA-Z\",\n    ascii: \"\\\\x00-\\\\x7F\",\n    blank: \" \\\\t\",\n    cntrl: \"\\\\x00-\\\\x1F\\\\x7F\",\n    digit: \"0-9\",\n    graph: \"\\\\x21-\\\\x7E\",\n    lower: \"a-z\",\n    print: \"\\\\x20-\\\\x7E \",\n    punct: \"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",\n    space: \" \\\\t\\\\r\\\\n\\\\v\\\\f\",\n    upper: \"A-Z\",\n    word: \"A-Za-z0-9_\",\n    xdigit: \"A-Fa-f0-9\"\n};\nmodule.exports = {\n    MAX_LENGTH: 1024 * 64,\n    POSIX_REGEX_SOURCE,\n    // regular expressions\n    REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n    REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n    REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n    REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n    // Replace globs with equivalent patterns to reduce parsing time.\n    REPLACEMENTS: {\n        \"***\": \"*\",\n        \"**/**\": \"**\",\n        \"**/**/**\": \"**\"\n    },\n    // Digits\n    CHAR_0: 48,\n    /* 0 */ CHAR_9: 57,\n    /* 9 */ // Alphabet chars.\n    CHAR_UPPERCASE_A: 65,\n    /* A */ CHAR_LOWERCASE_A: 97,\n    /* a */ CHAR_UPPERCASE_Z: 90,\n    /* Z */ CHAR_LOWERCASE_Z: 122,\n    /* z */ CHAR_LEFT_PARENTHESES: 40,\n    /* ( */ CHAR_RIGHT_PARENTHESES: 41,\n    /* ) */ CHAR_ASTERISK: 42,\n    /* * */ // Non-alphabetic chars.\n    CHAR_AMPERSAND: 38,\n    /* & */ CHAR_AT: 64,\n    /* @ */ CHAR_BACKWARD_SLASH: 92,\n    /* \\ */ CHAR_CARRIAGE_RETURN: 13,\n    /* \\r */ CHAR_CIRCUMFLEX_ACCENT: 94,\n    /* ^ */ CHAR_COLON: 58,\n    /* : */ CHAR_COMMA: 44,\n    /* , */ CHAR_DOT: 46,\n    /* . */ CHAR_DOUBLE_QUOTE: 34,\n    /* \" */ CHAR_EQUAL: 61,\n    /* = */ CHAR_EXCLAMATION_MARK: 33,\n    /* ! */ CHAR_FORM_FEED: 12,\n    /* \\f */ CHAR_FORWARD_SLASH: 47,\n    /* / */ CHAR_GRAVE_ACCENT: 96,\n    /* ` */ CHAR_HASH: 35,\n    /* # */ CHAR_HYPHEN_MINUS: 45,\n    /* - */ CHAR_LEFT_ANGLE_BRACKET: 60,\n    /* < */ CHAR_LEFT_CURLY_BRACE: 123,\n    /* { */ CHAR_LEFT_SQUARE_BRACKET: 91,\n    /* [ */ CHAR_LINE_FEED: 10,\n    /* \\n */ CHAR_NO_BREAK_SPACE: 160,\n    /* \\u00A0 */ CHAR_PERCENT: 37,\n    /* % */ CHAR_PLUS: 43,\n    /* + */ CHAR_QUESTION_MARK: 63,\n    /* ? */ CHAR_RIGHT_ANGLE_BRACKET: 62,\n    /* > */ CHAR_RIGHT_CURLY_BRACE: 125,\n    /* } */ CHAR_RIGHT_SQUARE_BRACKET: 93,\n    /* ] */ CHAR_SEMICOLON: 59,\n    /* ; */ CHAR_SINGLE_QUOTE: 39,\n    /* ' */ CHAR_SPACE: 32,\n    /*   */ CHAR_TAB: 9,\n    /* \\t */ CHAR_UNDERSCORE: 95,\n    /* _ */ CHAR_VERTICAL_LINE: 124,\n    /* | */ CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,\n    /* \\uFEFF */ SEP: path.sep,\n    /**\n   * Create EXTGLOB_CHARS\n   */ extglobChars (chars) {\n        return {\n            \"!\": {\n                type: \"negate\",\n                open: \"(?:(?!(?:\",\n                close: `))${chars.STAR})`\n            },\n            \"?\": {\n                type: \"qmark\",\n                open: \"(?:\",\n                close: \")?\"\n            },\n            \"+\": {\n                type: \"plus\",\n                open: \"(?:\",\n                close: \")+\"\n            },\n            \"*\": {\n                type: \"star\",\n                open: \"(?:\",\n                close: \")*\"\n            },\n            \"@\": {\n                type: \"at\",\n                open: \"(?:\",\n                close: \")\"\n            }\n        };\n    },\n    /**\n   * Create GLOB_CHARS\n   */ globChars (win32) {\n        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vcGljb21hdGNoQDIuMy4xL25vZGVfbW9kdWxlcy9waWNvbWF0Y2gvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLE9BQU9DLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1DLFlBQVk7QUFDbEIsTUFBTUMsZUFBZSxDQUFDLEVBQUUsRUFBRUQsVUFBVSxDQUFDLENBQUM7QUFFdEM7O0NBRUMsR0FFRCxNQUFNRSxjQUFjO0FBQ3BCLE1BQU1DLGVBQWU7QUFDckIsTUFBTUMsZ0JBQWdCO0FBQ3RCLE1BQU1DLGdCQUFnQjtBQUN0QixNQUFNQyxXQUFXO0FBQ2pCLE1BQU1DLFFBQVE7QUFDZCxNQUFNQyxhQUFhLENBQUMsR0FBRyxFQUFFSCxjQUFjLEdBQUcsQ0FBQztBQUMzQyxNQUFNSSxlQUFlLENBQUMsS0FBSyxFQUFFSixjQUFjLENBQUMsQ0FBQztBQUM3QyxNQUFNSyxhQUFhLENBQUMsRUFBRVIsWUFBWSxLQUFLLEVBQUVNLFdBQVcsQ0FBQztBQUNyRCxNQUFNRyxTQUFTLENBQUMsR0FBRyxFQUFFVCxZQUFZLENBQUMsQ0FBQztBQUNuQyxNQUFNVSxVQUFVLENBQUMsR0FBRyxFQUFFSCxhQUFhLEVBQUVDLFdBQVcsQ0FBQyxDQUFDO0FBQ2xELE1BQU1HLGVBQWUsQ0FBQyxHQUFHLEVBQUVYLFlBQVksS0FBSyxFQUFFTSxXQUFXLENBQUMsQ0FBQztBQUMzRCxNQUFNTSxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUVKLFdBQVcsQ0FBQyxDQUFDO0FBQ3pDLE1BQU1LLGVBQWUsQ0FBQyxHQUFHLEVBQUVWLGNBQWMsQ0FBQyxDQUFDO0FBQzNDLE1BQU1XLE9BQU8sQ0FBQyxFQUFFVCxNQUFNLEVBQUUsQ0FBQztBQUV6QixNQUFNVSxjQUFjO0lBQ2xCZjtJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBRTtJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNB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QkFBd0I7SUFBSyxLQUFLLEdBQ2xDQywyQkFBMkI7SUFBSSxLQUFLLEdBQ3BDQyxnQkFBZ0I7SUFBSSxLQUFLLEdBQ3pCQyxtQkFBbUI7SUFBSSxLQUFLLEdBQzVCQyxZQUFZO0lBQUksS0FBSyxHQUNyQkMsVUFBVTtJQUFHLE1BQU0sR0FDbkJDLGlCQUFpQjtJQUFJLEtBQUssR0FDMUJDLG9CQUFvQjtJQUFLLEtBQUssR0FDOUJDLCtCQUErQjtJQUFPLFVBQVUsR0FFaERDLEtBQUt6RixLQUFLMEYsR0FBRztJQUViOztHQUVDLEdBRURDLGNBQWFDLEtBQUs7UUFDaEIsT0FBTztZQUNMLEtBQUs7Z0JBQUVDLE1BQU07Z0JBQVVDLE1BQU07Z0JBQWFDLE9BQU8sQ0FBQyxFQUFFLEVBQUVILE1BQU0xRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQUM7WUFDcEUsS0FBSztnQkFBRTJFLE1BQU07Z0JBQVNDLE1BQU07Z0JBQU9DLE9BQU87WUFBSztZQUMvQyxLQUFLO2dCQUFFRixNQUFNO2dCQUFRQyxNQUFNO2dCQUFPQyxPQUFPO1lBQUs7WUFDOUMsS0FBSztnQkFBRUYsTUFBTTtnQkFBUUMsTUFBTTtnQkFBT0MsT0FBTztZQUFLO1lBQzlDLEtBQUs7Z0JBQUVGLE1BQU07Z0JBQU1DLE1BQU07Z0JBQU9DLE9BQU87WUFBSTtRQUM3QztJQUNGO0lBRUE7O0dBRUMsR0FFREMsV0FBVUMsS0FBSztRQUNiLE9BQU9BLFVBQVUsT0FBTzdFLGdCQUFnQkQ7SUFDMUM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3RhaWx3aW5kdWktc3R1ZGlvLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpY29tYXRjaEAyLjMuMS9ub2RlX21vZHVsZXMvcGljb21hdGNoL2xpYi9jb25zdGFudHMuanM/NTFkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBXSU5fU0xBU0ggPSAnXFxcXFxcXFwvJztcbmNvbnN0IFdJTl9OT19TTEFTSCA9IGBbXiR7V0lOX1NMQVNIfV1gO1xuXG4vKipcbiAqIFBvc2l4IGdsb2IgcmVnZXhcbiAqL1xuXG5jb25zdCBET1RfTElURVJBTCA9ICdcXFxcLic7XG5jb25zdCBQTFVTX0xJVEVSQUwgPSAnXFxcXCsnO1xuY29uc3QgUU1BUktfTElURVJBTCA9ICdcXFxcPyc7XG5jb25zdCBTTEFTSF9MSVRFUkFMID0gJ1xcXFwvJztcbmNvbnN0IE9ORV9DSEFSID0gJyg/PS4pJztcbmNvbnN0IFFNQVJLID0gJ1teL10nO1xuY29uc3QgRU5EX0FOQ0hPUiA9IGAoPzoke1NMQVNIX0xJVEVSQUx9fCQpYDtcbmNvbnN0IFNUQVJUX0FOQ0hPUiA9IGAoPzpefCR7U0xBU0hfTElURVJBTH0pYDtcbmNvbnN0IERPVFNfU0xBU0ggPSBgJHtET1RfTElURVJBTH17MSwyfSR7RU5EX0FOQ0hPUn1gO1xuY29uc3QgTk9fRE9UID0gYCg/ISR7RE9UX0xJVEVSQUx9KWA7XG5jb25zdCBOT19ET1RTID0gYCg/ISR7U1RBUlRfQU5DSE9SfSR7RE9UU19TTEFTSH0pYDtcbmNvbnN0IE5PX0RPVF9TTEFTSCA9IGAoPyEke0RPVF9MSVRFUkFMfXswLDF9JHtFTkRfQU5DSE9SfSlgO1xuY29uc3QgTk9fRE9UU19TTEFTSCA9IGAoPyEke0RPVFNfU0xBU0h9KWA7XG5jb25zdCBRTUFSS19OT19ET1QgPSBgW14uJHtTTEFTSF9MSVRFUkFMfV1gO1xuY29uc3QgU1RBUiA9IGAke1FNQVJLfSo/YDtcblxuY29uc3QgUE9TSVhfQ0hBUlMgPSB7XG4gIERPVF9MSVRFUkFMLFxuICBQTFVTX0xJVEVSQUwsXG4gIFFNQVJLX0xJVEVSQUwsXG4gIFNMQVNIX0xJVEVSQUwsXG4gIE9ORV9DSEFSLFxuICBRTUFSSyxcbiAgRU5EX0FOQ0hPUixcbiAgRE9UU19TTEFTSCxcbiAgTk9fRE9ULFxuICBOT19ET1RTLFxuICBOT19ET1RfU0xBU0gsXG4gIE5PX0RPVFNfU0xBU0gsXG4gIFFNQVJLX05PX0RPVCxcbiAgU1RBUixcbiAgU1RBUlRfQU5DSE9SXG59O1xuXG4vKipcbiAqIFdpbmRvd3MgZ2xvYiByZWdleFxuICovXG5cbmNvbnN0IFdJTkRPV1NfQ0hBUlMgPSB7XG4gIC4uLlBPU0lYX0NIQVJTLFxuXG4gIFNMQVNIX0xJVEVSQUw6IGBbJHtXSU5fU0xBU0h9XWAsXG4gIFFNQVJLOiBXSU5fTk9fU0xBU0gsXG4gIFNUQVI6IGAke1dJTl9OT19TTEFTSH0qP2AsXG4gIERPVFNfU0xBU0g6IGAke0RPVF9MSVRFUkFMfXsxLDJ9KD86WyR7V0lOX1NMQVNIfV18JClgLFxuICBOT19ET1Q6IGAoPyEke0RPVF9MSVRFUkFMfSlgLFxuICBOT19ET1RTOiBgKD8hKD86XnxbJHtXSU5fU0xBU0h9XSkke0RPVF9MSVRFUkFMfXsxLDJ9KD86WyR7V0lOX1NMQVNIfV18JCkpYCxcbiAgTk9fRE9UX1NMQVNIOiBgKD8hJHtET1RfTElURVJBTH17MCwxfSg/Olske1dJTl9TTEFTSH1dfCQpKWAsXG4gIE5PX0RPVFNfU0xBU0g6IGAoPyEke0RPVF9MSVRFUkFMfXsxLDJ9KD86WyR7V0lOX1NMQVNIfV18JCkpYCxcbiAgUU1BUktfTk9fRE9UOiBgW14uJHtXSU5fU0xBU0h9XWAsXG4gIFNUQVJUX0FOQ0hPUjogYCg/Ol58WyR7V0lOX1NMQVNIfV0pYCxcbiAgRU5EX0FOQ0hPUjogYCg/Olske1dJTl9TTEFTSH1dfCQpYFxufTtcblxuLyoqXG4gKiBQT1NJWCBCcmFja2V0IFJlZ2V4XG4gKi9cblxuY29uc3QgUE9TSVhfUkVHRVhfU09VUkNFID0ge1xuICBhbG51bTogJ2EtekEtWjAtOScsXG4gIGFscGhhOiAnYS16QS1aJyxcbiAgYXNjaWk6ICdcXFxceDAwLVxcXFx4N0YnLFxuICBibGFuazogJyBcXFxcdCcsXG4gIGNudHJsOiAnXFxcXHgwMC1cXFxceDFGXFxcXHg3RicsXG4gIGRpZ2l0OiAnMC05JyxcbiAgZ3JhcGg6ICdcXFxceDIxLVxcXFx4N0UnLFxuICBsb3dlcjogJ2EteicsXG4gIHByaW50OiAnXFxcXHgyMC1cXFxceDdFICcsXG4gIHB1bmN0OiAnXFxcXC0hXCIjJCUmXFwnKClcXFxcKissLi86Ozw9Pj9AW1xcXFxdXl9ge3x9ficsXG4gIHNwYWNlOiAnIFxcXFx0XFxcXHJcXFxcblxcXFx2XFxcXGYnLFxuICB1cHBlcjogJ0EtWicsXG4gIHdvcmQ6ICdBLVphLXowLTlfJyxcbiAgeGRpZ2l0OiAnQS1GYS1mMC05J1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE1BWF9MRU5HVEg6IDEwMjQgKiA2NCxcbiAgUE9TSVhfUkVHRVhfU09VUkNFLFxuXG4gIC8vIHJlZ3VsYXIgZXhwcmVzc2lvbnNcbiAgUkVHRVhfQkFDS1NMQVNIOiAvXFxcXCg/IVsqKz9eJHt9KHwpW1xcXV0pL2csXG4gIFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTOiAvXlteQCFbXFxdLiwkKis/Xnt9KCl8XFxcXC9dKy8sXG4gIFJFR0VYX1NQRUNJQUxfQ0hBUlM6IC9bLSorPy5eJHt9KHwpW1xcXV0vLFxuICBSRUdFWF9TUEVDSUFMX0NIQVJTX0JBQ0tSRUY6IC8oXFxcXD8pKChcXFcpKFxcMyopKS9nLFxuICBSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDogLyhbLSorPy5eJHt9KHwpW1xcXV0pL2csXG4gIFJFR0VYX1JFTU9WRV9CQUNLU0xBU0g6IC8oPzpcXFsuKj9bXlxcXFxdXFxdfFxcXFwoPz0uKSkvZyxcblxuICAvLyBSZXBsYWNlIGdsb2JzIHdpdGggZXF1aXZhbGVudCBwYXR0ZXJucyB0byByZWR1Y2UgcGFyc2luZyB0aW1lLlxuICBSRVBMQUNFTUVOVFM6IHtcbiAgICAnKioqJzogJyonLFxuICAgICcqKi8qKic6ICcqKicsXG4gICAgJyoqLyoqLyoqJzogJyoqJ1xuICB9LFxuXG4gIC8vIERpZ2l0c1xuICBDSEFSXzA6IDQ4LCAvKiAwICovXG4gIENIQVJfOTogNTcsIC8qIDkgKi9cblxuICAvLyBBbHBoYWJldCBjaGFycy5cbiAgQ0hBUl9VUFBFUkNBU0VfQTogNjUsIC8qIEEgKi9cbiAgQ0hBUl9MT1dFUkNBU0VfQTogOTcsIC8qIGEgKi9cbiAgQ0hBUl9VUFBFUkNBU0VfWjogOTAsIC8qIFogKi9cbiAgQ0hBUl9MT1dFUkNBU0VfWjogMTIyLCAvKiB6ICovXG5cbiAgQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOiA0MCwgLyogKCAqL1xuICBDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOiA0MSwgLyogKSAqL1xuXG4gIENIQVJfQVNURVJJU0s6IDQyLCAvKiAqICovXG5cbiAgLy8gTm9uLWFscGhhYmV0aWMgY2hhcnMuXG4gIENIQVJfQU1QRVJTQU5EOiAzOCwgLyogJiAqL1xuICBDSEFSX0FUOiA2NCwgLyogQCAqL1xuICBDSEFSX0JBQ0tXQVJEX1NMQVNIOiA5MiwgLyogXFwgKi9cbiAgQ0hBUl9DQVJSSUFHRV9SRVRVUk46IDEzLCAvKiBcXHIgKi9cbiAgQ0hBUl9DSVJDVU1GTEVYX0FDQ0VOVDogOTQsIC8qIF4gKi9cbiAgQ0hBUl9DT0xPTjogNTgsIC8qIDogKi9cbiAgQ0hBUl9DT01NQTogNDQsIC8qICwgKi9cbiAgQ0hBUl9ET1Q6IDQ2LCAvKiAuICovXG4gIENIQVJfRE9VQkxFX1FVT1RFOiAzNCwgLyogXCIgKi9cbiAgQ0hBUl9FUVVBTDogNjEsIC8qID0gKi9cbiAgQ0hBUl9FWENMQU1BVElPTl9NQVJLOiAzMywgLyogISAqL1xuICBDSEFSX0ZPUk1fRkVFRDogMTIsIC8qIFxcZiAqL1xuICBDSEFSX0ZPUldBUkRfU0xBU0g6IDQ3LCAvKiAvICovXG4gIENIQVJfR1JBVkVfQUNDRU5UOiA5NiwgLyogYCAqL1xuICBDSEFSX0hBU0g6IDM1LCAvKiAjICovXG4gIENIQVJfSFlQSEVOX01JTlVTOiA0NSwgLyogLSAqL1xuICBDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDogNjAsIC8qIDwgKi9cbiAgQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOiAxMjMsIC8qIHsgKi9cbiAgQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOiA5MSwgLyogWyAqL1xuICBDSEFSX0xJTkVfRkVFRDogMTAsIC8qIFxcbiAqL1xuICBDSEFSX05PX0JSRUFLX1NQQUNFOiAxNjAsIC8qIFxcdTAwQTAgKi9cbiAgQ0hBUl9QRVJDRU5UOiAzNywgLyogJSAqL1xuICBDSEFSX1BMVVM6IDQzLCAvKiArICovXG4gIENIQVJfUVVFU1RJT05fTUFSSzogNjMsIC8qID8gKi9cbiAgQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUOiA2MiwgLyogPiAqL1xuICBDSEFSX1JJR0hUX0NVUkxZX0JSQUNFOiAxMjUsIC8qIH0gKi9cbiAgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDogOTMsIC8qIF0gKi9cbiAgQ0hBUl9TRU1JQ09MT046IDU5LCAvKiA7ICovXG4gIENIQVJfU0lOR0xFX1FVT1RFOiAzOSwgLyogJyAqL1xuICBDSEFSX1NQQUNFOiAzMiwgLyogICAqL1xuICBDSEFSX1RBQjogOSwgLyogXFx0ICovXG4gIENIQVJfVU5ERVJTQ09SRTogOTUsIC8qIF8gKi9cbiAgQ0hBUl9WRVJUSUNBTF9MSU5FOiAxMjQsIC8qIHwgKi9cbiAgQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0U6IDY1Mjc5LCAvKiBcXHVGRUZGICovXG5cbiAgU0VQOiBwYXRoLnNlcCxcblxuICAvKipcbiAgICogQ3JlYXRlIEVYVEdMT0JfQ0hBUlNcbiAgICovXG5cbiAgZXh0Z2xvYkNoYXJzKGNoYXJzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICchJzogeyB0eXBlOiAnbmVnYXRlJywgb3BlbjogJyg/Oig/ISg/OicsIGNsb3NlOiBgKSkke2NoYXJzLlNUQVJ9KWAgfSxcbiAgICAgICc/JzogeyB0eXBlOiAncW1hcmsnLCBvcGVuOiAnKD86JywgY2xvc2U6ICcpPycgfSxcbiAgICAgICcrJzogeyB0eXBlOiAncGx1cycsIG9wZW46ICcoPzonLCBjbG9zZTogJykrJyB9LFxuICAgICAgJyonOiB7IHR5cGU6ICdzdGFyJywgb3BlbjogJyg/OicsIGNsb3NlOiAnKSonIH0sXG4gICAgICAnQCc6IHsgdHlwZTogJ2F0Jywgb3BlbjogJyg/OicsIGNsb3NlOiAnKScgfVxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBHTE9CX0NIQVJTXG4gICAqL1xuXG4gIGdsb2JDaGFycyh3aW4zMikge1xuICAgIHJldHVybiB3aW4zMiA9PT0gdHJ1ZSA/IFdJTkRPV1NfQ0hBUlMgOiBQT1NJWF9DSEFSUztcbiAgfVxufTtcbiJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsIldJTl9TTEFTSCIsIldJTl9OT19TTEFTSCIsIkRPVF9MSVRFUkFMIiwiUExVU19MSVRFUkFMIiwiUU1BUktfTElURVJBTCIsIlNMQVNIX0xJVEVSQUwiLCJPTkVfQ0hBUiIsIlFNQVJLIiwiRU5EX0FOQ0hPUiIsIlNUQVJUX0FOQ0hPUiIsIkRPVFNfU0xBU0giLCJOT19ET1QiLCJOT19ET1RTIiwiTk9fRE9UX1NMQVNIIiwiTk9fRE9UU19TTEFTSCIsIlFNQVJLX05PX0RPVCIsIlNUQVIiLCJQT1NJWF9DSEFSUyIsIldJTkRPV1NfQ0hBUlMiLCJQT1NJWF9SRUdFWF9TT1VSQ0UiLCJhbG51bSIsImFscGhhIiwiYXNjaWkiLCJibGFuayIsImNudHJsIiwiZGlnaXQiLCJncmFwaCIsImxvd2VyIiwicHJpbnQiLCJwdW5jdCIsInNwYWNlIiwidXBwZXIiLCJ3b3JkIiwieGRpZ2l0IiwibW9kdWxlIiwiZXhwb3J0cyIsIk1BWF9MRU5HVEgiLCJSRUdFWF9CQUNLU0xBU0giLCJSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUyIsIlJFR0VYX1NQRUNJQUxfQ0hBUlMiLCJSRUdFWF9TUEVDSUFMX0NIQVJTX0JBQ0tSRUYiLCJSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTCIsIlJFR0VYX1JFTU9WRV9CQUNLU0xBU0giLCJSRVBMQUNFTUVOVFMiLCJDSEFSXzAiLCJDSEFSXzkiLCJDSEFSX1VQUEVSQ0FTRV9BIiwiQ0hBUl9MT1dFUkNBU0VfQSIsIkNIQVJfVVBQRVJDQVNFX1oiLCJDSEFSX0xPV0VSQ0FTRV9aIiwiQ0hBUl9MRUZUX1BBUkVOVEhFU0VTIiwiQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUyIsIkNIQVJfQVNURVJJU0siLCJDSEFSX0FNUEVSU0FORCIsIkNIQVJfQVQiLCJDSEFSX0JBQ0tXQVJEX1NMQVNIIiwiQ0hBUl9DQVJSSUFHRV9SRVRVUk4iLCJDSEFSX0NJUkNVTUZMRVhfQUNDRU5UIiwiQ0hBUl9DT0xPTiIsIkNIQVJfQ09NTUEiLCJDSEFSX0RPVCIsIkNIQVJfRE9VQkxFX1FVT1RFIiwiQ0hBUl9FUVVBTCIsIkNIQVJfRVhDTEFNQVRJT05fTUFSSyIsIkNIQVJfRk9STV9GRUVEIiwiQ0hBUl9GT1JXQVJEX1NMQVNIIiwiQ0hBUl9HUkFWRV9BQ0NFTlQiLCJDSEFSX0hBU0giLCJDSEFSX0hZUEhFTl9NSU5VUyIsIkNIQVJfTEVGVF9BTkdMRV9CUkFDS0VUIiwiQ0hBUl9MRUZUX0NVUkxZX0JSQUNFIiwiQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUIiwiQ0hBUl9MSU5FX0ZFRUQiLCJDSEFSX05PX0JSRUFLX1NQQUNFIiwiQ0hBUl9QRVJDRU5UIiwiQ0hBUl9QTFVTIiwiQ0hBUl9RVUVTVElPTl9NQVJLIiwiQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUIiwiQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRSIsIkNIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQiLCJDSEFSX1NFTUlDT0xPTiIsIkNIQVJfU0lOR0xFX1FVT1RFIiwiQ0hBUl9TUEFDRSIsIkNIQVJfVEFCIiwiQ0hBUl9VTkRFUlNDT1JFIiwiQ0hBUl9WRVJUSUNBTF9MSU5FIiwiQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0UiLCJTRVAiLCJzZXAiLCJleHRnbG9iQ2hhcnMiLCJjaGFycyIsInR5cGUiLCJvcGVuIiwiY2xvc2UiLCJnbG9iQ2hhcnMiLCJ3aW4zMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst constants = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js\");\n/**\n * Constants\n */ const { MAX_LENGTH, POSIX_REGEX_SOURCE, REGEX_NON_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_BACKREF, REPLACEMENTS } = constants;\n/**\n * Helpers\n */ const expandRange = (args, options)=>{\n    if (typeof options.expandRange === \"function\") {\n        return options.expandRange(...args, options);\n    }\n    args.sort();\n    const value = `[${args.join(\"-\")}]`;\n    try {\n        /* eslint-disable-next-line no-new */ new RegExp(value);\n    } catch (ex) {\n        return args.map((v)=>utils.escapeRegex(v)).join(\"..\");\n    }\n    return value;\n};\n/**\n * Create the message for a syntax error\n */ const syntaxError = (type, char)=>{\n    return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */ const parse = (input, options)=>{\n    if (typeof input !== \"string\") {\n        throw new TypeError(\"Expected a string\");\n    }\n    input = REPLACEMENTS[input] || input;\n    const opts = {\n        ...options\n    };\n    const max = typeof opts.maxLength === \"number\" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n    let len = input.length;\n    if (len > max) {\n        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n    }\n    const bos = {\n        type: \"bos\",\n        value: \"\",\n        output: opts.prepend || \"\"\n    };\n    const tokens = [\n        bos\n    ];\n    const capture = opts.capture ? \"\" : \"?:\";\n    const win32 = utils.isWindows(options);\n    // create constants based on platform, for windows or posix\n    const PLATFORM_CHARS = constants.globChars(win32);\n    const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n    const { DOT_LITERAL, PLUS_LITERAL, SLASH_LITERAL, ONE_CHAR, DOTS_SLASH, NO_DOT, NO_DOT_SLASH, NO_DOTS_SLASH, QMARK, QMARK_NO_DOT, STAR, START_ANCHOR } = PLATFORM_CHARS;\n    const globstar = (opts)=>{\n        return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n    };\n    const nodot = opts.dot ? \"\" : NO_DOT;\n    const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n    let star = opts.bash === true ? globstar(opts) : STAR;\n    if (opts.capture) {\n        star = `(${star})`;\n    }\n    // minimatch options support\n    if (typeof opts.noext === \"boolean\") {\n        opts.noextglob = opts.noext;\n    }\n    const state = {\n        input,\n        index: -1,\n        start: 0,\n        dot: opts.dot === true,\n        consumed: \"\",\n        output: \"\",\n        prefix: \"\",\n        backtrack: false,\n        negated: false,\n        brackets: 0,\n        braces: 0,\n        parens: 0,\n        quotes: 0,\n        globstar: false,\n        tokens\n    };\n    input = utils.removePrefix(input, state);\n    len = input.length;\n    const extglobs = [];\n    const braces = [];\n    const stack = [];\n    let prev = bos;\n    let value;\n    /**\n   * Tokenizing helpers\n   */ const eos = ()=>state.index === len - 1;\n    const peek = state.peek = (n = 1)=>input[state.index + n];\n    const advance = state.advance = ()=>input[++state.index] || \"\";\n    const remaining = ()=>input.slice(state.index + 1);\n    const consume = (value = \"\", num = 0)=>{\n        state.consumed += value;\n        state.index += num;\n    };\n    const append = (token)=>{\n        state.output += token.output != null ? token.output : token.value;\n        consume(token.value);\n    };\n    const negate = ()=>{\n        let count = 1;\n        while(peek() === \"!\" && (peek(2) !== \"(\" || peek(3) === \"?\")){\n            advance();\n            state.start++;\n            count++;\n        }\n        if (count % 2 === 0) {\n            return false;\n        }\n        state.negated = true;\n        state.start++;\n        return true;\n    };\n    const increment = (type)=>{\n        state[type]++;\n        stack.push(type);\n    };\n    const decrement = (type)=>{\n        state[type]--;\n        stack.pop();\n    };\n    /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */ const push = (tok)=>{\n        if (prev.type === \"globstar\") {\n            const isBrace = state.braces > 0 && (tok.type === \"comma\" || tok.type === \"brace\");\n            const isExtglob = tok.extglob === true || extglobs.length && (tok.type === \"pipe\" || tok.type === \"paren\");\n            if (tok.type !== \"slash\" && tok.type !== \"paren\" && !isBrace && !isExtglob) {\n                state.output = state.output.slice(0, -prev.output.length);\n                prev.type = \"star\";\n                prev.value = \"*\";\n                prev.output = star;\n                state.output += prev.output;\n            }\n        }\n        if (extglobs.length && tok.type !== \"paren\") {\n            extglobs[extglobs.length - 1].inner += tok.value;\n        }\n        if (tok.value || tok.output) append(tok);\n        if (prev && prev.type === \"text\" && tok.type === \"text\") {\n            prev.value += tok.value;\n            prev.output = (prev.output || \"\") + tok.value;\n            return;\n        }\n        tok.prev = prev;\n        tokens.push(tok);\n        prev = tok;\n    };\n    const extglobOpen = (type, value)=>{\n        const token = {\n            ...EXTGLOB_CHARS[value],\n            conditions: 1,\n            inner: \"\"\n        };\n        token.prev = prev;\n        token.parens = state.parens;\n        token.output = state.output;\n        const output = (opts.capture ? \"(\" : \"\") + token.open;\n        increment(\"parens\");\n        push({\n            type,\n            value,\n            output: state.output ? \"\" : ONE_CHAR\n        });\n        push({\n            type: \"paren\",\n            extglob: true,\n            value: advance(),\n            output\n        });\n        extglobs.push(token);\n    };\n    const extglobClose = (token)=>{\n        let output = token.close + (opts.capture ? \")\" : \"\");\n        let rest;\n        if (token.type === \"negate\") {\n            let extglobStar = star;\n            if (token.inner && token.inner.length > 1 && token.inner.includes(\"/\")) {\n                extglobStar = globstar(opts);\n            }\n            if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n                output = token.close = `)$))${extglobStar}`;\n            }\n            if (token.inner.includes(\"*\") && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n                // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n                // In this case, we need to parse the string and use it in the output of the original pattern.\n                // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n                //\n                // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n                const expression = parse(rest, {\n                    ...options,\n                    fastpaths: false\n                }).output;\n                output = token.close = `)${expression})${extglobStar})`;\n            }\n            if (token.prev.type === \"bos\") {\n                state.negatedExtglob = true;\n            }\n        }\n        push({\n            type: \"paren\",\n            extglob: true,\n            value,\n            output\n        });\n        decrement(\"parens\");\n    };\n    /**\n   * Fast paths\n   */ if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n        let backslashes = false;\n        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index)=>{\n            if (first === \"\\\\\") {\n                backslashes = true;\n                return m;\n            }\n            if (first === \"?\") {\n                if (esc) {\n                    return esc + first + (rest ? QMARK.repeat(rest.length) : \"\");\n                }\n                if (index === 0) {\n                    return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : \"\");\n                }\n                return QMARK.repeat(chars.length);\n            }\n            if (first === \".\") {\n                return DOT_LITERAL.repeat(chars.length);\n            }\n            if (first === \"*\") {\n                if (esc) {\n                    return esc + first + (rest ? star : \"\");\n                }\n                return star;\n            }\n            return esc ? m : `\\\\${m}`;\n        });\n        if (backslashes === true) {\n            if (opts.unescape === true) {\n                output = output.replace(/\\\\/g, \"\");\n            } else {\n                output = output.replace(/\\\\+/g, (m)=>{\n                    return m.length % 2 === 0 ? \"\\\\\\\\\" : m ? \"\\\\\" : \"\";\n                });\n            }\n        }\n        if (output === input && opts.contains === true) {\n            state.output = input;\n            return state;\n        }\n        state.output = utils.wrapOutput(output, state, options);\n        return state;\n    }\n    /**\n   * Tokenize input until we reach end-of-string\n   */ while(!eos()){\n        value = advance();\n        if (value === \"\\x00\") {\n            continue;\n        }\n        /**\n     * Escaped characters\n     */ if (value === \"\\\\\") {\n            const next = peek();\n            if (next === \"/\" && opts.bash !== true) {\n                continue;\n            }\n            if (next === \".\" || next === \";\") {\n                continue;\n            }\n            if (!next) {\n                value += \"\\\\\";\n                push({\n                    type: \"text\",\n                    value\n                });\n                continue;\n            }\n            // collapse slashes to reduce potential for exploits\n            const match = /^\\\\+/.exec(remaining());\n            let slashes = 0;\n            if (match && match[0].length > 2) {\n                slashes = match[0].length;\n                state.index += slashes;\n                if (slashes % 2 !== 0) {\n                    value += \"\\\\\";\n                }\n            }\n            if (opts.unescape === true) {\n                value = advance();\n            } else {\n                value += advance();\n            }\n            if (state.brackets === 0) {\n                push({\n                    type: \"text\",\n                    value\n                });\n                continue;\n            }\n        }\n        /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */ if (state.brackets > 0 && (value !== \"]\" || prev.value === \"[\" || prev.value === \"[^\")) {\n            if (opts.posix !== false && value === \":\") {\n                const inner = prev.value.slice(1);\n                if (inner.includes(\"[\")) {\n                    prev.posix = true;\n                    if (inner.includes(\":\")) {\n                        const idx = prev.value.lastIndexOf(\"[\");\n                        const pre = prev.value.slice(0, idx);\n                        const rest = prev.value.slice(idx + 2);\n                        const posix = POSIX_REGEX_SOURCE[rest];\n                        if (posix) {\n                            prev.value = pre + posix;\n                            state.backtrack = true;\n                            advance();\n                            if (!bos.output && tokens.indexOf(prev) === 1) {\n                                bos.output = ONE_CHAR;\n                            }\n                            continue;\n                        }\n                    }\n                }\n            }\n            if (value === \"[\" && peek() !== \":\" || value === \"-\" && peek() === \"]\") {\n                value = `\\\\${value}`;\n            }\n            if (value === \"]\" && (prev.value === \"[\" || prev.value === \"[^\")) {\n                value = `\\\\${value}`;\n            }\n            if (opts.posix === true && value === \"!\" && prev.value === \"[\") {\n                value = \"^\";\n            }\n            prev.value += value;\n            append({\n                value\n            });\n            continue;\n        }\n        /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */ if (state.quotes === 1 && value !== '\"') {\n            value = utils.escapeRegex(value);\n            prev.value += value;\n            append({\n                value\n            });\n            continue;\n        }\n        /**\n     * Double quotes\n     */ if (value === '\"') {\n            state.quotes = state.quotes === 1 ? 0 : 1;\n            if (opts.keepQuotes === true) {\n                push({\n                    type: \"text\",\n                    value\n                });\n            }\n            continue;\n        }\n        /**\n     * Parentheses\n     */ if (value === \"(\") {\n            increment(\"parens\");\n            push({\n                type: \"paren\",\n                value\n            });\n            continue;\n        }\n        if (value === \")\") {\n            if (state.parens === 0 && opts.strictBrackets === true) {\n                throw new SyntaxError(syntaxError(\"opening\", \"(\"));\n            }\n            const extglob = extglobs[extglobs.length - 1];\n            if (extglob && state.parens === extglob.parens + 1) {\n                extglobClose(extglobs.pop());\n                continue;\n            }\n            push({\n                type: \"paren\",\n                value,\n                output: state.parens ? \")\" : \"\\\\)\"\n            });\n            decrement(\"parens\");\n            continue;\n        }\n        /**\n     * Square brackets\n     */ if (value === \"[\") {\n            if (opts.nobracket === true || !remaining().includes(\"]\")) {\n                if (opts.nobracket !== true && opts.strictBrackets === true) {\n                    throw new SyntaxError(syntaxError(\"closing\", \"]\"));\n                }\n                value = `\\\\${value}`;\n            } else {\n                increment(\"brackets\");\n            }\n            push({\n                type: \"bracket\",\n                value\n            });\n            continue;\n        }\n        if (value === \"]\") {\n            if (opts.nobracket === true || prev && prev.type === \"bracket\" && prev.value.length === 1) {\n                push({\n                    type: \"text\",\n                    value,\n                    output: `\\\\${value}`\n                });\n                continue;\n            }\n            if (state.brackets === 0) {\n                if (opts.strictBrackets === true) {\n                    throw new SyntaxError(syntaxError(\"opening\", \"[\"));\n                }\n                push({\n                    type: \"text\",\n                    value,\n                    output: `\\\\${value}`\n                });\n                continue;\n            }\n            decrement(\"brackets\");\n            const prevValue = prev.value.slice(1);\n            if (prev.posix !== true && prevValue[0] === \"^\" && !prevValue.includes(\"/\")) {\n                value = `/${value}`;\n            }\n            prev.value += value;\n            append({\n                value\n            });\n            // when literal brackets are explicitly disabled\n            // assume we should match with a regex character class\n            if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n                continue;\n            }\n            const escaped = utils.escapeRegex(prev.value);\n            state.output = state.output.slice(0, -prev.value.length);\n            // when literal brackets are explicitly enabled\n            // assume we should escape the brackets to match literal characters\n            if (opts.literalBrackets === true) {\n                state.output += escaped;\n                prev.value = escaped;\n                continue;\n            }\n            // when the user specifies nothing, try to match both\n            prev.value = `(${capture}${escaped}|${prev.value})`;\n            state.output += prev.value;\n            continue;\n        }\n        /**\n     * Braces\n     */ if (value === \"{\" && opts.nobrace !== true) {\n            increment(\"braces\");\n            const open = {\n                type: \"brace\",\n                value,\n                output: \"(\",\n                outputIndex: state.output.length,\n                tokensIndex: state.tokens.length\n            };\n            braces.push(open);\n            push(open);\n            continue;\n        }\n        if (value === \"}\") {\n            const brace = braces[braces.length - 1];\n            if (opts.nobrace === true || !brace) {\n                push({\n                    type: \"text\",\n                    value,\n                    output: value\n                });\n                continue;\n            }\n            let output = \")\";\n            if (brace.dots === true) {\n                const arr = tokens.slice();\n                const range = [];\n                for(let i = arr.length - 1; i >= 0; i--){\n                    tokens.pop();\n                    if (arr[i].type === \"brace\") {\n                        break;\n                    }\n                    if (arr[i].type !== \"dots\") {\n                        range.unshift(arr[i].value);\n                    }\n                }\n                output = expandRange(range, opts);\n                state.backtrack = true;\n            }\n            if (brace.comma !== true && brace.dots !== true) {\n                const out = state.output.slice(0, brace.outputIndex);\n                const toks = state.tokens.slice(brace.tokensIndex);\n                brace.value = brace.output = \"\\\\{\";\n                value = output = \"\\\\}\";\n                state.output = out;\n                for (const t of toks){\n                    state.output += t.output || t.value;\n                }\n            }\n            push({\n                type: \"brace\",\n                value,\n                output\n            });\n            decrement(\"braces\");\n            braces.pop();\n            continue;\n        }\n        /**\n     * Pipes\n     */ if (value === \"|\") {\n            if (extglobs.length > 0) {\n                extglobs[extglobs.length - 1].conditions++;\n            }\n            push({\n                type: \"text\",\n                value\n            });\n            continue;\n        }\n        /**\n     * Commas\n     */ if (value === \",\") {\n            let output = value;\n            const brace = braces[braces.length - 1];\n            if (brace && stack[stack.length - 1] === \"braces\") {\n                brace.comma = true;\n                output = \"|\";\n            }\n            push({\n                type: \"comma\",\n                value,\n                output\n            });\n            continue;\n        }\n        /**\n     * Slashes\n     */ if (value === \"/\") {\n            // if the beginning of the glob is \"./\", advance the start\n            // to the current index, and don't add the \"./\" characters\n            // to the state. This greatly simplifies lookbehinds when\n            // checking for BOS characters like \"!\" and \".\" (not \"./\")\n            if (prev.type === \"dot\" && state.index === state.start + 1) {\n                state.start = state.index + 1;\n                state.consumed = \"\";\n                state.output = \"\";\n                tokens.pop();\n                prev = bos; // reset \"prev\" to the first token\n                continue;\n            }\n            push({\n                type: \"slash\",\n                value,\n                output: SLASH_LITERAL\n            });\n            continue;\n        }\n        /**\n     * Dots\n     */ if (value === \".\") {\n            if (state.braces > 0 && prev.type === \"dot\") {\n                if (prev.value === \".\") prev.output = DOT_LITERAL;\n                const brace = braces[braces.length - 1];\n                prev.type = \"dots\";\n                prev.output += value;\n                prev.value += value;\n                brace.dots = true;\n                continue;\n            }\n            if (state.braces + state.parens === 0 && prev.type !== \"bos\" && prev.type !== \"slash\") {\n                push({\n                    type: \"text\",\n                    value,\n                    output: DOT_LITERAL\n                });\n                continue;\n            }\n            push({\n                type: \"dot\",\n                value,\n                output: DOT_LITERAL\n            });\n            continue;\n        }\n        /**\n     * Question marks\n     */ if (value === \"?\") {\n            const isGroup = prev && prev.value === \"(\";\n            if (!isGroup && opts.noextglob !== true && peek() === \"(\" && peek(2) !== \"?\") {\n                extglobOpen(\"qmark\", value);\n                continue;\n            }\n            if (prev && prev.type === \"paren\") {\n                const next = peek();\n                let output = value;\n                if (next === \"<\" && !utils.supportsLookbehinds()) {\n                    throw new Error(\"Node.js v10 or higher is required for regex lookbehinds\");\n                }\n                if (prev.value === \"(\" && !/[!=<:]/.test(next) || next === \"<\" && !/<([!=]|\\w+>)/.test(remaining())) {\n                    output = `\\\\${value}`;\n                }\n                push({\n                    type: \"text\",\n                    value,\n                    output\n                });\n                continue;\n            }\n            if (opts.dot !== true && (prev.type === \"slash\" || prev.type === \"bos\")) {\n                push({\n                    type: \"qmark\",\n                    value,\n                    output: QMARK_NO_DOT\n                });\n                continue;\n            }\n            push({\n                type: \"qmark\",\n                value,\n                output: QMARK\n            });\n            continue;\n        }\n        /**\n     * Exclamation\n     */ if (value === \"!\") {\n            if (opts.noextglob !== true && peek() === \"(\") {\n                if (peek(2) !== \"?\" || !/[!=<:]/.test(peek(3))) {\n                    extglobOpen(\"negate\", value);\n                    continue;\n                }\n            }\n            if (opts.nonegate !== true && state.index === 0) {\n                negate();\n                continue;\n            }\n        }\n        /**\n     * Plus\n     */ if (value === \"+\") {\n            if (opts.noextglob !== true && peek() === \"(\" && peek(2) !== \"?\") {\n                extglobOpen(\"plus\", value);\n                continue;\n            }\n            if (prev && prev.value === \"(\" || opts.regex === false) {\n                push({\n                    type: \"plus\",\n                    value,\n                    output: PLUS_LITERAL\n                });\n                continue;\n            }\n            if (prev && (prev.type === \"bracket\" || prev.type === \"paren\" || prev.type === \"brace\") || state.parens > 0) {\n                push({\n                    type: \"plus\",\n                    value\n                });\n                continue;\n            }\n            push({\n                type: \"plus\",\n                value: PLUS_LITERAL\n            });\n            continue;\n        }\n        /**\n     * Plain text\n     */ if (value === \"@\") {\n            if (opts.noextglob !== true && peek() === \"(\" && peek(2) !== \"?\") {\n                push({\n                    type: \"at\",\n                    extglob: true,\n                    value,\n                    output: \"\"\n                });\n                continue;\n            }\n            push({\n                type: \"text\",\n                value\n            });\n            continue;\n        }\n        /**\n     * Plain text\n     */ if (value !== \"*\") {\n            if (value === \"$\" || value === \"^\") {\n                value = `\\\\${value}`;\n            }\n            const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n            if (match) {\n                value += match[0];\n                state.index += match[0].length;\n            }\n            push({\n                type: \"text\",\n                value\n            });\n            continue;\n        }\n        /**\n     * Stars\n     */ if (prev && (prev.type === \"globstar\" || prev.star === true)) {\n            prev.type = \"star\";\n            prev.star = true;\n            prev.value += value;\n            prev.output = star;\n            state.backtrack = true;\n            state.globstar = true;\n            consume(value);\n            continue;\n        }\n        let rest = remaining();\n        if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n            extglobOpen(\"star\", value);\n            continue;\n        }\n        if (prev.type === \"star\") {\n            if (opts.noglobstar === true) {\n                consume(value);\n                continue;\n            }\n            const prior = prev.prev;\n            const before = prior.prev;\n            const isStart = prior.type === \"slash\" || prior.type === \"bos\";\n            const afterStar = before && (before.type === \"star\" || before.type === \"globstar\");\n            if (opts.bash === true && (!isStart || rest[0] && rest[0] !== \"/\")) {\n                push({\n                    type: \"star\",\n                    value,\n                    output: \"\"\n                });\n                continue;\n            }\n            const isBrace = state.braces > 0 && (prior.type === \"comma\" || prior.type === \"brace\");\n            const isExtglob = extglobs.length && (prior.type === \"pipe\" || prior.type === \"paren\");\n            if (!isStart && prior.type !== \"paren\" && !isBrace && !isExtglob) {\n                push({\n                    type: \"star\",\n                    value,\n                    output: \"\"\n                });\n                continue;\n            }\n            // strip consecutive `/**/`\n            while(rest.slice(0, 3) === \"/**\"){\n                const after = input[state.index + 4];\n                if (after && after !== \"/\") {\n                    break;\n                }\n                rest = rest.slice(3);\n                consume(\"/**\", 3);\n            }\n            if (prior.type === \"bos\" && eos()) {\n                prev.type = \"globstar\";\n                prev.value += value;\n                prev.output = globstar(opts);\n                state.output = prev.output;\n                state.globstar = true;\n                consume(value);\n                continue;\n            }\n            if (prior.type === \"slash\" && prior.prev.type !== \"bos\" && !afterStar && eos()) {\n                state.output = state.output.slice(0, -(prior.output + prev.output).length);\n                prior.output = `(?:${prior.output}`;\n                prev.type = \"globstar\";\n                prev.output = globstar(opts) + (opts.strictSlashes ? \")\" : \"|$)\");\n                prev.value += value;\n                state.globstar = true;\n                state.output += prior.output + prev.output;\n                consume(value);\n                continue;\n            }\n            if (prior.type === \"slash\" && prior.prev.type !== \"bos\" && rest[0] === \"/\") {\n                const end = rest[1] !== void 0 ? \"|$\" : \"\";\n                state.output = state.output.slice(0, -(prior.output + prev.output).length);\n                prior.output = `(?:${prior.output}`;\n                prev.type = \"globstar\";\n                prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n                prev.value += value;\n                state.output += prior.output + prev.output;\n                state.globstar = true;\n                consume(value + advance());\n                push({\n                    type: \"slash\",\n                    value: \"/\",\n                    output: \"\"\n                });\n                continue;\n            }\n            if (prior.type === \"bos\" && rest[0] === \"/\") {\n                prev.type = \"globstar\";\n                prev.value += value;\n                prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n                state.output = prev.output;\n                state.globstar = true;\n                consume(value + advance());\n                push({\n                    type: \"slash\",\n                    value: \"/\",\n                    output: \"\"\n                });\n                continue;\n            }\n            // remove single star from output\n            state.output = state.output.slice(0, -prev.output.length);\n            // reset previous token to globstar\n            prev.type = \"globstar\";\n            prev.output = globstar(opts);\n            prev.value += value;\n            // reset output with globstar\n            state.output += prev.output;\n            state.globstar = true;\n            consume(value);\n            continue;\n        }\n        const token = {\n            type: \"star\",\n            value,\n            output: star\n        };\n        if (opts.bash === true) {\n            token.output = \".*?\";\n            if (prev.type === \"bos\" || prev.type === \"slash\") {\n                token.output = nodot + token.output;\n            }\n            push(token);\n            continue;\n        }\n        if (prev && (prev.type === \"bracket\" || prev.type === \"paren\") && opts.regex === true) {\n            token.output = value;\n            push(token);\n            continue;\n        }\n        if (state.index === state.start || prev.type === \"slash\" || prev.type === \"dot\") {\n            if (prev.type === \"dot\") {\n                state.output += NO_DOT_SLASH;\n                prev.output += NO_DOT_SLASH;\n            } else if (opts.dot === true) {\n                state.output += NO_DOTS_SLASH;\n                prev.output += NO_DOTS_SLASH;\n            } else {\n                state.output += nodot;\n                prev.output += nodot;\n            }\n            if (peek() !== \"*\") {\n                state.output += ONE_CHAR;\n                prev.output += ONE_CHAR;\n            }\n        }\n        push(token);\n    }\n    while(state.brackets > 0){\n        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \"]\"));\n        state.output = utils.escapeLast(state.output, \"[\");\n        decrement(\"brackets\");\n    }\n    while(state.parens > 0){\n        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \")\"));\n        state.output = utils.escapeLast(state.output, \"(\");\n        decrement(\"parens\");\n    }\n    while(state.braces > 0){\n        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \"}\"));\n        state.output = utils.escapeLast(state.output, \"{\");\n        decrement(\"braces\");\n    }\n    if (opts.strictSlashes !== true && (prev.type === \"star\" || prev.type === \"bracket\")) {\n        push({\n            type: \"maybe_slash\",\n            value: \"\",\n            output: `${SLASH_LITERAL}?`\n        });\n    }\n    // rebuild the output if we had to backtrack at any point\n    if (state.backtrack === true) {\n        state.output = \"\";\n        for (const token of state.tokens){\n            state.output += token.output != null ? token.output : token.value;\n            if (token.suffix) {\n                state.output += token.suffix;\n            }\n        }\n    }\n    return state;\n};\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */ parse.fastpaths = (input, options)=>{\n    const opts = {\n        ...options\n    };\n    const max = typeof opts.maxLength === \"number\" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n    const len = input.length;\n    if (len > max) {\n        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n    }\n    input = REPLACEMENTS[input] || input;\n    const win32 = utils.isWindows(options);\n    // create constants based on platform, for windows or posix\n    const { DOT_LITERAL, SLASH_LITERAL, ONE_CHAR, DOTS_SLASH, NO_DOT, NO_DOTS, NO_DOTS_SLASH, STAR, START_ANCHOR } = constants.globChars(win32);\n    const nodot = opts.dot ? NO_DOTS : NO_DOT;\n    const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n    const capture = opts.capture ? \"\" : \"?:\";\n    const state = {\n        negated: false,\n        prefix: \"\"\n    };\n    let star = opts.bash === true ? \".*?\" : STAR;\n    if (opts.capture) {\n        star = `(${star})`;\n    }\n    const globstar = (opts)=>{\n        if (opts.noglobstar === true) return star;\n        return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n    };\n    const create = (str)=>{\n        switch(str){\n            case \"*\":\n                return `${nodot}${ONE_CHAR}${star}`;\n            case \".*\":\n                return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n            case \"*.*\":\n                return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n            case \"*/*\":\n                return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n            case \"**\":\n                return nodot + globstar(opts);\n            case \"**/*\":\n                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n            case \"**/*.*\":\n                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n            case \"**/.*\":\n                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n            default:\n                {\n                    const match = /^(.*?)\\.(\\w+)$/.exec(str);\n                    if (!match) return;\n                    const source = create(match[1]);\n                    if (!source) return;\n                    return source + DOT_LITERAL + match[2];\n                }\n        }\n    };\n    const output = utils.removePrefix(input, state);\n    let source = create(output);\n    if (source && opts.strictSlashes !== true) {\n        source += `${SLASH_LITERAL}?`;\n    }\n    return source;\n};\nmodule.exports = parse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vcGljb21hdGNoQDIuMy4xL25vZGVfbW9kdWxlcy9waWNvbWF0Y2gvbGliL3BhcnNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsWUFBWUMsbUJBQU9BLENBQUM7QUFDMUIsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUM7QUFFdEI7O0NBRUMsR0FFRCxNQUFNLEVBQ0pFLFVBQVUsRUFDVkMsa0JBQWtCLEVBQ2xCQyx1QkFBdUIsRUFDdkJDLDJCQUEyQixFQUMzQkMsWUFBWSxFQUNiLEdBQUdQO0FBRUo7O0NBRUMsR0FFRCxNQUFNUSxjQUFjLENBQUNDLE1BQU1DO0lBQ3pCLElBQUksT0FBT0EsUUFBUUYsV0FBVyxLQUFLLFlBQVk7UUFDN0MsT0FBT0UsUUFBUUYsV0FBVyxJQUFJQyxNQUFNQztJQUN0QztJQUVBRCxLQUFLRSxJQUFJO0lBQ1QsTUFBTUMsUUFBUSxDQUFDLENBQUMsRUFBRUgsS0FBS0ksSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRW5DLElBQUk7UUFDRixtQ0FBbUMsR0FDbkMsSUFBSUMsT0FBT0Y7SUFDYixFQUFFLE9BQU9HLElBQUk7UUFDWCxPQUFPTixLQUFLTyxHQUFHLENBQUNDLENBQUFBLElBQUtmLE1BQU1nQixXQUFXLENBQUNELElBQUlKLElBQUksQ0FBQztJQUNsRDtJQUVBLE9BQU9EO0FBQ1Q7QUFFQTs7Q0FFQyxHQUVELE1BQU1PLGNBQWMsQ0FBQ0MsTUFBTUM7SUFDekIsT0FBTyxDQUFDLFFBQVEsRUFBRUQsS0FBSyxHQUFHLEVBQUVDLEtBQUssYUFBYSxFQUFFQSxLQUFLLDZCQUE2QixDQUFDO0FBQ3JGO0FBRUE7Ozs7O0NBS0MsR0FFRCxNQUFNQyxRQUFRLENBQUNDLE9BQU9iO0lBQ3BCLElBQUksT0FBT2EsVUFBVSxVQUFVO1FBQzdCLE1BQU0sSUFBSUMsVUFBVTtJQUN0QjtJQUVBRCxRQUFRaEIsWUFBWSxDQUFDZ0IsTUFBTSxJQUFJQTtJQUUvQixNQUFNRSxPQUFP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LE9BQU8sQ0FBQyxHQUFHLEVBQUVGLE1BQU0sRUFBRUYsU0FBUy9CLE1BQU0sRUFBRXFCLGNBQWMsRUFBRSxFQUFFRixZQUFZLEVBQUVHLFNBQVMsRUFBRWEsS0FBSyxDQUFDO1lBRXpGO2dCQUFTO29CQUNQLE1BQU0rRCxRQUFRLGlCQUFpQkMsSUFBSSxDQUFDNkM7b0JBQ3BDLElBQUksQ0FBQzlDLE9BQU87b0JBRVosTUFBTStDLFNBQVNGLE9BQU83QyxLQUFLLENBQUMsRUFBRTtvQkFDOUIsSUFBSSxDQUFDK0MsUUFBUTtvQkFFYixPQUFPQSxTQUFTOUgsY0FBYytFLEtBQUssQ0FBQyxFQUFFO2dCQUN4QztRQUNGO0lBQ0Y7SUFFQSxNQUFNekYsU0FBU2hDLE1BQU15RSxZQUFZLENBQUNwRCxPQUFPeUM7SUFDekMsSUFBSTBHLFNBQVNGLE9BQU90STtJQUVwQixJQUFJd0ksVUFBVWpKLEtBQUt5SSxhQUFhLEtBQUssTUFBTTtRQUN6Q1EsVUFBVSxDQUFDLEVBQUU1SCxjQUFjLENBQUMsQ0FBQztJQUMvQjtJQUVBLE9BQU80SDtBQUNUO0FBRUFDLE9BQU9DLE9BQU8sR0FBR3RKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGFpbHdpbmR1aS1zdHVkaW8vLi9ub2RlX21vZHVsZXMvLnBucG0vcGljb21hdGNoQDIuMy4xL25vZGVfbW9kdWxlcy9waWNvbWF0Y2gvbGliL3BhcnNlLmpzP2E5YTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3Qge1xuICBNQVhfTEVOR1RILFxuICBQT1NJWF9SRUdFWF9TT1VSQ0UsXG4gIFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTLFxuICBSRUdFWF9TUEVDSUFMX0NIQVJTX0JBQ0tSRUYsXG4gIFJFUExBQ0VNRU5UU1xufSA9IGNvbnN0YW50cztcblxuLyoqXG4gKiBIZWxwZXJzXG4gKi9cblxuY29uc3QgZXhwYW5kUmFuZ2UgPSAoYXJncywgb3B0aW9ucykgPT4ge1xuICBpZiAodHlwZW9mIG9wdGlvbnMuZXhwYW5kUmFuZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5leHBhbmRSYW5nZSguLi5hcmdzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGFyZ3Muc29ydCgpO1xuICBjb25zdCB2YWx1ZSA9IGBbJHthcmdzLmpvaW4oJy0nKX1dYDtcblxuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXcgKi9cbiAgICBuZXcgUmVnRXhwKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICByZXR1cm4gYXJncy5tYXAodiA9PiB1dGlscy5lc2NhcGVSZWdleCh2KSkuam9pbignLi4nKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBtZXNzYWdlIGZvciBhIHN5bnRheCBlcnJvclxuICovXG5cbmNvbnN0IHN5bnRheEVycm9yID0gKHR5cGUsIGNoYXIpID0+IHtcbiAgcmV0dXJuIGBNaXNzaW5nICR7dHlwZX06IFwiJHtjaGFyfVwiIC0gdXNlIFwiXFxcXFxcXFwke2NoYXJ9XCIgdG8gbWF0Y2ggbGl0ZXJhbCBjaGFyYWN0ZXJzYDtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGlucHV0IHN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5jb25zdCBwYXJzZSA9IChpbnB1dCwgb3B0aW9ucykgPT4ge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cblxuICBpbnB1dCA9IFJFUExBQ0VNRU5UU1tpbnB1dF0gfHwgaW5wdXQ7XG5cbiAgY29uc3Qgb3B0cyA9IHsgLi4ub3B0aW9ucyB9O1xuICBjb25zdCBtYXggPSB0eXBlb2Ygb3B0cy5tYXhMZW5ndGggPT09ICdudW1iZXInID8gTWF0aC5taW4oTUFYX0xFTkdUSCwgb3B0cy5tYXhMZW5ndGgpIDogTUFYX0xFTkdUSDtcblxuICBsZXQgbGVuID0gaW5wdXQubGVuZ3RoO1xuICBpZiAobGVuID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnB1dCBsZW5ndGg6ICR7bGVufSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke21heH1gKTtcbiAgfVxuXG4gIGNvbnN0IGJvcyA9IHsgdHlwZTogJ2JvcycsIHZhbHVlOiAnJywgb3V0cHV0OiBvcHRzLnByZXBlbmQgfHwgJycgfTtcbiAgY29uc3QgdG9rZW5zID0gW2Jvc107XG5cbiAgY29uc3QgY2FwdHVyZSA9IG9wdHMuY2FwdHVyZSA/ICcnIDogJz86JztcbiAgY29uc3Qgd2luMzIgPSB1dGlscy5pc1dpbmRvd3Mob3B0aW9ucyk7XG5cbiAgLy8gY3JlYXRlIGNvbnN0YW50cyBiYXNlZCBvbiBwbGF0Zm9ybSwgZm9yIHdpbmRvd3Mgb3IgcG9zaXhcbiAgY29uc3QgUExBVEZPUk1fQ0hBUlMgPSBjb25zdGFudHMuZ2xvYkNoYXJzKHdpbjMyKTtcbiAgY29uc3QgRVhUR0xPQl9DSEFSUyA9IGNvbnN0YW50cy5leHRnbG9iQ2hhcnMoUExBVEZPUk1fQ0hBUlMpO1xuXG4gIGNvbnN0IHtcbiAgICBET1RfTElURVJBTCxcbiAgICBQTFVTX0xJVEVSQUwsXG4gICAgU0xBU0hfTElURVJBTCxcbiAgICBPTkVfQ0hBUixcbiAgICBET1RTX1NMQVNILFxuICAgIE5PX0RPVCxcbiAgICBOT19ET1RfU0xBU0gsXG4gICAgTk9fRE9UU19TTEFTSCxcbiAgICBRTUFSSyxcbiAgICBRTUFSS19OT19ET1QsXG4gICAgU1RBUixcbiAgICBTVEFSVF9BTkNIT1JcbiAgfSA9IFBMQVRGT1JNX0NIQVJTO1xuXG4gIGNvbnN0IGdsb2JzdGFyID0gb3B0cyA9PiB7XG4gICAgcmV0dXJuIGAoJHtjYXB0dXJlfSg/Oig/ISR7U1RBUlRfQU5DSE9SfSR7b3B0cy5kb3QgPyBET1RTX1NMQVNIIDogRE9UX0xJVEVSQUx9KS4pKj8pYDtcbiAgfTtcblxuICBjb25zdCBub2RvdCA9IG9wdHMuZG90ID8gJycgOiBOT19ET1Q7XG4gIGNvbnN0IHFtYXJrTm9Eb3QgPSBvcHRzLmRvdCA/IFFNQVJLIDogUU1BUktfTk9fRE9UO1xuICBsZXQgc3RhciA9IG9wdHMuYmFzaCA9PT0gdHJ1ZSA/IGdsb2JzdGFyKG9wdHMpIDogU1RBUjtcblxuICBpZiAob3B0cy5jYXB0dXJlKSB7XG4gICAgc3RhciA9IGAoJHtzdGFyfSlgO1xuICB9XG5cbiAgLy8gbWluaW1hdGNoIG9wdGlvbnMgc3VwcG9ydFxuICBpZiAodHlwZW9mIG9wdHMubm9leHQgPT09ICdib29sZWFuJykge1xuICAgIG9wdHMubm9leHRnbG9iID0gb3B0cy5ub2V4dDtcbiAgfVxuXG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIGlucHV0LFxuICAgIGluZGV4OiAtMSxcbiAgICBzdGFydDogMCxcbiAgICBkb3Q6IG9wdHMuZG90ID09PSB0cnVlLFxuICAgIGNvbnN1bWVkOiAnJyxcbiAgICBvdXRwdXQ6ICcnLFxuICAgIHByZWZpeDogJycsXG4gICAgYmFja3RyYWNrOiBmYWxzZSxcbiAgICBuZWdhdGVkOiBmYWxzZSxcbiAgICBicmFja2V0czogMCxcbiAgICBicmFjZXM6IDAsXG4gICAgcGFyZW5zOiAwLFxuICAgIHF1b3RlczogMCxcbiAgICBnbG9ic3RhcjogZmFsc2UsXG4gICAgdG9rZW5zXG4gIH07XG5cbiAgaW5wdXQgPSB1dGlscy5yZW1vdmVQcmVmaXgoaW5wdXQsIHN0YXRlKTtcbiAgbGVuID0gaW5wdXQubGVuZ3RoO1xuXG4gIGNvbnN0IGV4dGdsb2JzID0gW107XG4gIGNvbnN0IGJyYWNlcyA9IFtdO1xuICBjb25zdCBzdGFjayA9IFtdO1xuICBsZXQgcHJldiA9IGJvcztcbiAgbGV0IHZhbHVlO1xuXG4gIC8qKlxuICAgKiBUb2tlbml6aW5nIGhlbHBlcnNcbiAgICovXG5cbiAgY29uc3QgZW9zID0gKCkgPT4gc3RhdGUuaW5kZXggPT09IGxlbiAtIDE7XG4gIGNvbnN0IHBlZWsgPSBzdGF0ZS5wZWVrID0gKG4gPSAxKSA9PiBpbnB1dFtzdGF0ZS5pbmRleCArIG5dO1xuICBjb25zdCBhZHZhbmNlID0gc3RhdGUuYWR2YW5jZSA9ICgpID0+IGlucHV0Wysrc3RhdGUuaW5kZXhdIHx8ICcnO1xuICBjb25zdCByZW1haW5pbmcgPSAoKSA9PiBpbnB1dC5zbGljZShzdGF0ZS5pbmRleCArIDEpO1xuICBjb25zdCBjb25zdW1lID0gKHZhbHVlID0gJycsIG51bSA9IDApID0+IHtcbiAgICBzdGF0ZS5jb25zdW1lZCArPSB2YWx1ZTtcbiAgICBzdGF0ZS5pbmRleCArPSBudW07XG4gIH07XG5cbiAgY29uc3QgYXBwZW5kID0gdG9rZW4gPT4ge1xuICAgIHN0YXRlLm91dHB1dCArPSB0b2tlbi5vdXRwdXQgIT0gbnVsbCA/IHRva2VuLm91dHB1dCA6IHRva2VuLnZhbHVlO1xuICAgIGNvbnN1bWUodG9rZW4udmFsdWUpO1xuICB9O1xuXG4gIGNvbnN0IG5lZ2F0ZSA9ICgpID0+IHtcbiAgICBsZXQgY291bnQgPSAxO1xuXG4gICAgd2hpbGUgKHBlZWsoKSA9PT0gJyEnICYmIChwZWVrKDIpICE9PSAnKCcgfHwgcGVlaygzKSA9PT0gJz8nKSkge1xuICAgICAgYWR2YW5jZSgpO1xuICAgICAgc3RhdGUuc3RhcnQrKztcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuXG4gICAgaWYgKGNvdW50ICUgMiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN0YXRlLm5lZ2F0ZWQgPSB0cnVlO1xuICAgIHN0YXRlLnN0YXJ0Kys7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgY29uc3QgaW5jcmVtZW50ID0gdHlwZSA9PiB7XG4gICAgc3RhdGVbdHlwZV0rKztcbiAgICBzdGFjay5wdXNoKHR5cGUpO1xuICB9O1xuXG4gIGNvbnN0IGRlY3JlbWVudCA9IHR5cGUgPT4ge1xuICAgIHN0YXRlW3R5cGVdLS07XG4gICAgc3RhY2sucG9wKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1c2ggdG9rZW5zIG9udG8gdGhlIHRva2VucyBhcnJheS4gVGhpcyBoZWxwZXIgc3BlZWRzIHVwXG4gICAqIHRva2VuaXppbmcgYnkgMSkgaGVscGluZyB1cyBhdm9pZCBiYWNrdHJhY2tpbmcgYXMgbXVjaCBhcyBwb3NzaWJsZSxcbiAgICogYW5kIDIpIGhlbHBpbmcgdXMgYXZvaWQgY3JlYXRpbmcgZXh0cmEgdG9rZW5zIHdoZW4gY29uc2VjdXRpdmVcbiAgICogY2hhcmFjdGVycyBhcmUgcGxhaW4gdGV4dC4gVGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBhbmQgc2ltcGxpZmllc1xuICAgKiBsb29rYmVoaW5kcy5cbiAgICovXG5cbiAgY29uc3QgcHVzaCA9IHRvayA9PiB7XG4gICAgaWYgKHByZXYudHlwZSA9PT0gJ2dsb2JzdGFyJykge1xuICAgICAgY29uc3QgaXNCcmFjZSA9IHN0YXRlLmJyYWNlcyA+IDAgJiYgKHRvay50eXBlID09PSAnY29tbWEnIHx8IHRvay50eXBlID09PSAnYnJhY2UnKTtcbiAgICAgIGNvbnN0IGlzRXh0Z2xvYiA9IHRvay5leHRnbG9iID09PSB0cnVlIHx8IChleHRnbG9icy5sZW5ndGggJiYgKHRvay50eXBlID09PSAncGlwZScgfHwgdG9rLnR5cGUgPT09ICdwYXJlbicpKTtcblxuICAgICAgaWYgKHRvay50eXBlICE9PSAnc2xhc2gnICYmIHRvay50eXBlICE9PSAncGFyZW4nICYmICFpc0JyYWNlICYmICFpc0V4dGdsb2IpIHtcbiAgICAgICAgc3RhdGUub3V0cHV0ID0gc3RhdGUub3V0cHV0LnNsaWNlKDAsIC1wcmV2Lm91dHB1dC5sZW5ndGgpO1xuICAgICAgICBwcmV2LnR5cGUgPSAnc3Rhcic7XG4gICAgICAgIHByZXYudmFsdWUgPSAnKic7XG4gICAgICAgIHByZXYub3V0cHV0ID0gc3RhcjtcbiAgICAgICAgc3RhdGUub3V0cHV0ICs9IHByZXYub3V0cHV0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHRnbG9icy5sZW5ndGggJiYgdG9rLnR5cGUgIT09ICdwYXJlbicpIHtcbiAgICAgIGV4dGdsb2JzW2V4dGdsb2JzLmxlbmd0aCAtIDFdLmlubmVyICs9IHRvay52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodG9rLnZhbHVlIHx8IHRvay5vdXRwdXQpIGFwcGVuZCh0b2spO1xuICAgIGlmIChwcmV2ICYmIHByZXYudHlwZSA9PT0gJ3RleHQnICYmIHRvay50eXBlID09PSAndGV4dCcpIHtcbiAgICAgIHByZXYudmFsdWUgKz0gdG9rLnZhbHVlO1xuICAgICAgcHJldi5vdXRwdXQgPSAocHJldi5vdXRwdXQgfHwgJycpICsgdG9rLnZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRvay5wcmV2ID0gcHJldjtcbiAgICB0b2tlbnMucHVzaCh0b2spO1xuICAgIHByZXYgPSB0b2s7XG4gIH07XG5cbiAgY29uc3QgZXh0Z2xvYk9wZW4gPSAodHlwZSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCB0b2tlbiA9IHsgLi4uRVhUR0xPQl9DSEFSU1t2YWx1ZV0sIGNvbmRpdGlvbnM6IDEsIGlubmVyOiAnJyB9O1xuXG4gICAgdG9rZW4ucHJldiA9IHByZXY7XG4gICAgdG9rZW4ucGFyZW5zID0gc3RhdGUucGFyZW5zO1xuICAgIHRva2VuLm91dHB1dCA9IHN0YXRlLm91dHB1dDtcbiAgICBjb25zdCBvdXRwdXQgPSAob3B0cy5jYXB0dXJlID8gJygnIDogJycpICsgdG9rZW4ub3BlbjtcblxuICAgIGluY3JlbWVudCgncGFyZW5zJyk7XG4gICAgcHVzaCh7IHR5cGUsIHZhbHVlLCBvdXRwdXQ6IHN0YXRlLm91dHB1dCA/ICcnIDogT05FX0NIQVIgfSk7XG4gICAgcHVzaCh7IHR5cGU6ICdwYXJlbicsIGV4dGdsb2I6IHRydWUsIHZhbHVlOiBhZHZhbmNlKCksIG91dHB1dCB9KTtcbiAgICBleHRnbG9icy5wdXNoKHRva2VuKTtcbiAgfTtcblxuICBjb25zdCBleHRnbG9iQ2xvc2UgPSB0b2tlbiA9PiB7XG4gICAgbGV0IG91dHB1dCA9IHRva2VuLmNsb3NlICsgKG9wdHMuY2FwdHVyZSA/ICcpJyA6ICcnKTtcbiAgICBsZXQgcmVzdDtcblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbmVnYXRlJykge1xuICAgICAgbGV0IGV4dGdsb2JTdGFyID0gc3RhcjtcblxuICAgICAgaWYgKHRva2VuLmlubmVyICYmIHRva2VuLmlubmVyLmxlbmd0aCA+IDEgJiYgdG9rZW4uaW5uZXIuaW5jbHVkZXMoJy8nKSkge1xuICAgICAgICBleHRnbG9iU3RhciA9IGdsb2JzdGFyKG9wdHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXh0Z2xvYlN0YXIgIT09IHN0YXIgfHwgZW9zKCkgfHwgL15cXCkrJC8udGVzdChyZW1haW5pbmcoKSkpIHtcbiAgICAgICAgb3V0cHV0ID0gdG9rZW4uY2xvc2UgPSBgKSQpKSR7ZXh0Z2xvYlN0YXJ9YDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLmlubmVyLmluY2x1ZGVzKCcqJykgJiYgKHJlc3QgPSByZW1haW5pbmcoKSkgJiYgL15cXC5bXlxcXFwvLl0rJC8udGVzdChyZXN0KSkge1xuICAgICAgICAvLyBBbnkgbm9uLW1hZ2ljYWwgc3RyaW5nIChgLnRzYCkgb3IgZXZlbiBuZXN0ZWQgZXhwcmVzc2lvbiAoYC57dHMsdHN4fWApIGNhbiBmb2xsb3cgYWZ0ZXIgdGhlIGNsb3NpbmcgcGFyZW50aGVzaXMuXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSwgd2UgbmVlZCB0byBwYXJzZSB0aGUgc3RyaW5nIGFuZCB1c2UgaXQgaW4gdGhlIG91dHB1dCBvZiB0aGUgb3JpZ2luYWwgcGF0dGVybi5cbiAgICAgICAgLy8gU3VpdGFibGUgcGF0dGVybnM6IGAvISgqLmQpLnRzYCwgYC8hKCouZCkue3RzLHRzeH1gLCBgKiovISgqLWRiZykuQChqcylgLlxuICAgICAgICAvL1xuICAgICAgICAvLyBEaXNhYmxpbmcgdGhlIGBmYXN0cGF0aHNgIG9wdGlvbiBkdWUgdG8gYSBwcm9ibGVtIHdpdGggcGFyc2luZyBzdHJpbmdzIGFzIGAudHNgIGluIHRoZSBwYXR0ZXJuIGxpa2UgYCoqLyEoKi5kKS50c2AuXG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBwYXJzZShyZXN0LCB7IC4uLm9wdGlvbnMsIGZhc3RwYXRoczogZmFsc2UgfSkub3V0cHV0O1xuXG4gICAgICAgIG91dHB1dCA9IHRva2VuLmNsb3NlID0gYCkke2V4cHJlc3Npb259KSR7ZXh0Z2xvYlN0YXJ9KWA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi5wcmV2LnR5cGUgPT09ICdib3MnKSB7XG4gICAgICAgIHN0YXRlLm5lZ2F0ZWRFeHRnbG9iID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwdXNoKHsgdHlwZTogJ3BhcmVuJywgZXh0Z2xvYjogdHJ1ZSwgdmFsdWUsIG91dHB1dCB9KTtcbiAgICBkZWNyZW1lbnQoJ3BhcmVucycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGYXN0IHBhdGhzXG4gICAqL1xuXG4gIGlmIChvcHRzLmZhc3RwYXRocyAhPT0gZmFsc2UgJiYgIS8oXlsqIV18Wy8oKVtcXF17fVwiXSkvLnRlc3QoaW5wdXQpKSB7XG4gICAgbGV0IGJhY2tzbGFzaGVzID0gZmFsc2U7XG5cbiAgICBsZXQgb3V0cHV0ID0gaW5wdXQucmVwbGFjZShSRUdFWF9TUEVDSUFMX0NIQVJTX0JBQ0tSRUYsIChtLCBlc2MsIGNoYXJzLCBmaXJzdCwgcmVzdCwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChmaXJzdCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGJhY2tzbGFzaGVzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdCA9PT0gJz8nKSB7XG4gICAgICAgIGlmIChlc2MpIHtcbiAgICAgICAgICByZXR1cm4gZXNjICsgZmlyc3QgKyAocmVzdCA/IFFNQVJLLnJlcGVhdChyZXN0Lmxlbmd0aCkgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHFtYXJrTm9Eb3QgKyAocmVzdCA/IFFNQVJLLnJlcGVhdChyZXN0Lmxlbmd0aCkgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFFNQVJLLnJlcGVhdChjaGFycy5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlyc3QgPT09ICcuJykge1xuICAgICAgICByZXR1cm4gRE9UX0xJVEVSQUwucmVwZWF0KGNoYXJzLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdCA9PT0gJyonKSB7XG4gICAgICAgIGlmIChlc2MpIHtcbiAgICAgICAgICByZXR1cm4gZXNjICsgZmlyc3QgKyAocmVzdCA/IHN0YXIgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXNjID8gbSA6IGBcXFxcJHttfWA7XG4gICAgfSk7XG5cbiAgICBpZiAoYmFja3NsYXNoZXMgPT09IHRydWUpIHtcbiAgICAgIGlmIChvcHRzLnVuZXNjYXBlID09PSB0cnVlKSB7XG4gICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC9cXFxcKy9nLCBtID0+IHtcbiAgICAgICAgICByZXR1cm4gbS5sZW5ndGggJSAyID09PSAwID8gJ1xcXFxcXFxcJyA6IChtID8gJ1xcXFwnIDogJycpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3V0cHV0ID09PSBpbnB1dCAmJiBvcHRzLmNvbnRhaW5zID09PSB0cnVlKSB7XG4gICAgICBzdGF0ZS5vdXRwdXQgPSBpbnB1dDtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICBzdGF0ZS5vdXRwdXQgPSB1dGlscy53cmFwT3V0cHV0KG91dHB1dCwgc3RhdGUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2tlbml6ZSBpbnB1dCB1bnRpbCB3ZSByZWFjaCBlbmQtb2Ytc3RyaW5nXG4gICAqL1xuXG4gIHdoaWxlICghZW9zKCkpIHtcbiAgICB2YWx1ZSA9IGFkdmFuY2UoKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gJ1xcdTAwMDAnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGVkIGNoYXJhY3RlcnNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJ1xcXFwnKSB7XG4gICAgICBjb25zdCBuZXh0ID0gcGVlaygpO1xuXG4gICAgICBpZiAobmV4dCA9PT0gJy8nICYmIG9wdHMuYmFzaCAhPT0gdHJ1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHQgPT09ICcuJyB8fCBuZXh0ID09PSAnOycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghbmV4dCkge1xuICAgICAgICB2YWx1ZSArPSAnXFxcXCc7XG4gICAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gY29sbGFwc2Ugc2xhc2hlcyB0byByZWR1Y2UgcG90ZW50aWFsIGZvciBleHBsb2l0c1xuICAgICAgY29uc3QgbWF0Y2ggPSAvXlxcXFwrLy5leGVjKHJlbWFpbmluZygpKTtcbiAgICAgIGxldCBzbGFzaGVzID0gMDtcblxuICAgICAgaWYgKG1hdGNoICYmIG1hdGNoWzBdLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgc2xhc2hlcyA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgc3RhdGUuaW5kZXggKz0gc2xhc2hlcztcbiAgICAgICAgaWYgKHNsYXNoZXMgJSAyICE9PSAwKSB7XG4gICAgICAgICAgdmFsdWUgKz0gJ1xcXFwnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLnVuZXNjYXBlID09PSB0cnVlKSB7XG4gICAgICAgIHZhbHVlID0gYWR2YW5jZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgKz0gYWR2YW5jZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUuYnJhY2tldHMgPT09IDApIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHdlJ3JlIGluc2lkZSBhIHJlZ2V4IGNoYXJhY3RlciBjbGFzcywgY29udGludWVcbiAgICAgKiB1bnRpbCB3ZSByZWFjaCB0aGUgY2xvc2luZyBicmFja2V0LlxuICAgICAqL1xuXG4gICAgaWYgKHN0YXRlLmJyYWNrZXRzID4gMCAmJiAodmFsdWUgIT09ICddJyB8fCBwcmV2LnZhbHVlID09PSAnWycgfHwgcHJldi52YWx1ZSA9PT0gJ1teJykpIHtcbiAgICAgIGlmIChvcHRzLnBvc2l4ICE9PSBmYWxzZSAmJiB2YWx1ZSA9PT0gJzonKSB7XG4gICAgICAgIGNvbnN0IGlubmVyID0gcHJldi52YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgaWYgKGlubmVyLmluY2x1ZGVzKCdbJykpIHtcbiAgICAgICAgICBwcmV2LnBvc2l4ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChpbm5lci5pbmNsdWRlcygnOicpKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBwcmV2LnZhbHVlLmxhc3RJbmRleE9mKCdbJyk7XG4gICAgICAgICAgICBjb25zdCBwcmUgPSBwcmV2LnZhbHVlLnNsaWNlKDAsIGlkeCk7XG4gICAgICAgICAgICBjb25zdCByZXN0ID0gcHJldi52YWx1ZS5zbGljZShpZHggKyAyKTtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l4ID0gUE9TSVhfUkVHRVhfU09VUkNFW3Jlc3RdO1xuICAgICAgICAgICAgaWYgKHBvc2l4KSB7XG4gICAgICAgICAgICAgIHByZXYudmFsdWUgPSBwcmUgKyBwb3NpeDtcbiAgICAgICAgICAgICAgc3RhdGUuYmFja3RyYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYWR2YW5jZSgpO1xuXG4gICAgICAgICAgICAgIGlmICghYm9zLm91dHB1dCAmJiB0b2tlbnMuaW5kZXhPZihwcmV2KSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGJvcy5vdXRwdXQgPSBPTkVfQ0hBUjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCh2YWx1ZSA9PT0gJ1snICYmIHBlZWsoKSAhPT0gJzonKSB8fCAodmFsdWUgPT09ICctJyAmJiBwZWVrKCkgPT09ICddJykpIHtcbiAgICAgICAgdmFsdWUgPSBgXFxcXCR7dmFsdWV9YDtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlID09PSAnXScgJiYgKHByZXYudmFsdWUgPT09ICdbJyB8fCBwcmV2LnZhbHVlID09PSAnW14nKSkge1xuICAgICAgICB2YWx1ZSA9IGBcXFxcJHt2YWx1ZX1gO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0cy5wb3NpeCA9PT0gdHJ1ZSAmJiB2YWx1ZSA9PT0gJyEnICYmIHByZXYudmFsdWUgPT09ICdbJykge1xuICAgICAgICB2YWx1ZSA9ICdeJztcbiAgICAgIH1cblxuICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcbiAgICAgIGFwcGVuZCh7IHZhbHVlIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgd2UncmUgaW5zaWRlIGEgcXVvdGVkIHN0cmluZywgY29udGludWVcbiAgICAgKiB1bnRpbCB3ZSByZWFjaCB0aGUgY2xvc2luZyBkb3VibGUgcXVvdGUuXG4gICAgICovXG5cbiAgICBpZiAoc3RhdGUucXVvdGVzID09PSAxICYmIHZhbHVlICE9PSAnXCInKSB7XG4gICAgICB2YWx1ZSA9IHV0aWxzLmVzY2FwZVJlZ2V4KHZhbHVlKTtcbiAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG4gICAgICBhcHBlbmQoeyB2YWx1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvdWJsZSBxdW90ZXNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJ1wiJykge1xuICAgICAgc3RhdGUucXVvdGVzID0gc3RhdGUucXVvdGVzID09PSAxID8gMCA6IDE7XG4gICAgICBpZiAob3B0cy5rZWVwUXVvdGVzID09PSB0cnVlKSB7XG4gICAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlIH0pO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyZW50aGVzZXNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJygnKSB7XG4gICAgICBpbmNyZW1lbnQoJ3BhcmVucycpO1xuICAgICAgcHVzaCh7IHR5cGU6ICdwYXJlbicsIHZhbHVlIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnKScpIHtcbiAgICAgIGlmIChzdGF0ZS5wYXJlbnMgPT09IDAgJiYgb3B0cy5zdHJpY3RCcmFja2V0cyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoJ29wZW5pbmcnLCAnKCcpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXh0Z2xvYiA9IGV4dGdsb2JzW2V4dGdsb2JzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGV4dGdsb2IgJiYgc3RhdGUucGFyZW5zID09PSBleHRnbG9iLnBhcmVucyArIDEpIHtcbiAgICAgICAgZXh0Z2xvYkNsb3NlKGV4dGdsb2JzLnBvcCgpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAncGFyZW4nLCB2YWx1ZSwgb3V0cHV0OiBzdGF0ZS5wYXJlbnMgPyAnKScgOiAnXFxcXCknIH0pO1xuICAgICAgZGVjcmVtZW50KCdwYXJlbnMnKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNxdWFyZSBicmFja2V0c1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAnWycpIHtcbiAgICAgIGlmIChvcHRzLm5vYnJhY2tldCA9PT0gdHJ1ZSB8fCAhcmVtYWluaW5nKCkuaW5jbHVkZXMoJ10nKSkge1xuICAgICAgICBpZiAob3B0cy5ub2JyYWNrZXQgIT09IHRydWUgJiYgb3B0cy5zdHJpY3RCcmFja2V0cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcignY2xvc2luZycsICddJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSBgXFxcXCR7dmFsdWV9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluY3JlbWVudCgnYnJhY2tldHMnKTtcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICdicmFja2V0JywgdmFsdWUgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09ICddJykge1xuICAgICAgaWYgKG9wdHMubm9icmFja2V0ID09PSB0cnVlIHx8IChwcmV2ICYmIHByZXYudHlwZSA9PT0gJ2JyYWNrZXQnICYmIHByZXYudmFsdWUubGVuZ3RoID09PSAxKSkge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSwgb3V0cHV0OiBgXFxcXCR7dmFsdWV9YCB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5icmFja2V0cyA9PT0gMCkge1xuICAgICAgICBpZiAob3B0cy5zdHJpY3RCcmFja2V0cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcignb3BlbmluZycsICdbJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUsIG91dHB1dDogYFxcXFwke3ZhbHVlfWAgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkZWNyZW1lbnQoJ2JyYWNrZXRzJyk7XG5cbiAgICAgIGNvbnN0IHByZXZWYWx1ZSA9IHByZXYudmFsdWUuc2xpY2UoMSk7XG4gICAgICBpZiAocHJldi5wb3NpeCAhPT0gdHJ1ZSAmJiBwcmV2VmFsdWVbMF0gPT09ICdeJyAmJiAhcHJldlZhbHVlLmluY2x1ZGVzKCcvJykpIHtcbiAgICAgICAgdmFsdWUgPSBgLyR7dmFsdWV9YDtcbiAgICAgIH1cblxuICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcbiAgICAgIGFwcGVuZCh7IHZhbHVlIH0pO1xuXG4gICAgICAvLyB3aGVuIGxpdGVyYWwgYnJhY2tldHMgYXJlIGV4cGxpY2l0bHkgZGlzYWJsZWRcbiAgICAgIC8vIGFzc3VtZSB3ZSBzaG91bGQgbWF0Y2ggd2l0aCBhIHJlZ2V4IGNoYXJhY3RlciBjbGFzc1xuICAgICAgaWYgKG9wdHMubGl0ZXJhbEJyYWNrZXRzID09PSBmYWxzZSB8fCB1dGlscy5oYXNSZWdleENoYXJzKHByZXZWYWx1ZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVzY2FwZWQgPSB1dGlscy5lc2NhcGVSZWdleChwcmV2LnZhbHVlKTtcbiAgICAgIHN0YXRlLm91dHB1dCA9IHN0YXRlLm91dHB1dC5zbGljZSgwLCAtcHJldi52YWx1ZS5sZW5ndGgpO1xuXG4gICAgICAvLyB3aGVuIGxpdGVyYWwgYnJhY2tldHMgYXJlIGV4cGxpY2l0bHkgZW5hYmxlZFxuICAgICAgLy8gYXNzdW1lIHdlIHNob3VsZCBlc2NhcGUgdGhlIGJyYWNrZXRzIHRvIG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyc1xuICAgICAgaWYgKG9wdHMubGl0ZXJhbEJyYWNrZXRzID09PSB0cnVlKSB7XG4gICAgICAgIHN0YXRlLm91dHB1dCArPSBlc2NhcGVkO1xuICAgICAgICBwcmV2LnZhbHVlID0gZXNjYXBlZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHdoZW4gdGhlIHVzZXIgc3BlY2lmaWVzIG5vdGhpbmcsIHRyeSB0byBtYXRjaCBib3RoXG4gICAgICBwcmV2LnZhbHVlID0gYCgke2NhcHR1cmV9JHtlc2NhcGVkfXwke3ByZXYudmFsdWV9KWA7XG4gICAgICBzdGF0ZS5vdXRwdXQgKz0gcHJldi52YWx1ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJyYWNlc1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAneycgJiYgb3B0cy5ub2JyYWNlICE9PSB0cnVlKSB7XG4gICAgICBpbmNyZW1lbnQoJ2JyYWNlcycpO1xuXG4gICAgICBjb25zdCBvcGVuID0ge1xuICAgICAgICB0eXBlOiAnYnJhY2UnLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb3V0cHV0OiAnKCcsXG4gICAgICAgIG91dHB1dEluZGV4OiBzdGF0ZS5vdXRwdXQubGVuZ3RoLFxuICAgICAgICB0b2tlbnNJbmRleDogc3RhdGUudG9rZW5zLmxlbmd0aFxuICAgICAgfTtcblxuICAgICAgYnJhY2VzLnB1c2gob3Blbik7XG4gICAgICBwdXNoKG9wZW4pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnfScpIHtcbiAgICAgIGNvbnN0IGJyYWNlID0gYnJhY2VzW2JyYWNlcy5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKG9wdHMubm9icmFjZSA9PT0gdHJ1ZSB8fCAhYnJhY2UpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUsIG91dHB1dDogdmFsdWUgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgb3V0cHV0ID0gJyknO1xuXG4gICAgICBpZiAoYnJhY2UuZG90cyA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBhcnIgPSB0b2tlbnMuc2xpY2UoKTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICAgIGlmIChhcnJbaV0udHlwZSA9PT0gJ2JyYWNlJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhcnJbaV0udHlwZSAhPT0gJ2RvdHMnKSB7XG4gICAgICAgICAgICByYW5nZS51bnNoaWZ0KGFycltpXS52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0ID0gZXhwYW5kUmFuZ2UocmFuZ2UsIG9wdHMpO1xuICAgICAgICBzdGF0ZS5iYWNrdHJhY2sgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnJhY2UuY29tbWEgIT09IHRydWUgJiYgYnJhY2UuZG90cyAhPT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBvdXQgPSBzdGF0ZS5vdXRwdXQuc2xpY2UoMCwgYnJhY2Uub3V0cHV0SW5kZXgpO1xuICAgICAgICBjb25zdCB0b2tzID0gc3RhdGUudG9rZW5zLnNsaWNlKGJyYWNlLnRva2Vuc0luZGV4KTtcbiAgICAgICAgYnJhY2UudmFsdWUgPSBicmFjZS5vdXRwdXQgPSAnXFxcXHsnO1xuICAgICAgICB2YWx1ZSA9IG91dHB1dCA9ICdcXFxcfSc7XG4gICAgICAgIHN0YXRlLm91dHB1dCA9IG91dDtcbiAgICAgICAgZm9yIChjb25zdCB0IG9mIHRva3MpIHtcbiAgICAgICAgICBzdGF0ZS5vdXRwdXQgKz0gKHQub3V0cHV0IHx8IHQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAnYnJhY2UnLCB2YWx1ZSwgb3V0cHV0IH0pO1xuICAgICAgZGVjcmVtZW50KCdicmFjZXMnKTtcbiAgICAgIGJyYWNlcy5wb3AoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBpcGVzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICd8Jykge1xuICAgICAgaWYgKGV4dGdsb2JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZXh0Z2xvYnNbZXh0Z2xvYnMubGVuZ3RoIC0gMV0uY29uZGl0aW9ucysrO1xuICAgICAgfVxuICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21tYXNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJywnKSB7XG4gICAgICBsZXQgb3V0cHV0ID0gdmFsdWU7XG5cbiAgICAgIGNvbnN0IGJyYWNlID0gYnJhY2VzW2JyYWNlcy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChicmFjZSAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gJ2JyYWNlcycpIHtcbiAgICAgICAgYnJhY2UuY29tbWEgPSB0cnVlO1xuICAgICAgICBvdXRwdXQgPSAnfCc7XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAnY29tbWEnLCB2YWx1ZSwgb3V0cHV0IH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2xhc2hlc1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAnLycpIHtcbiAgICAgIC8vIGlmIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGdsb2IgaXMgXCIuL1wiLCBhZHZhbmNlIHRoZSBzdGFydFxuICAgICAgLy8gdG8gdGhlIGN1cnJlbnQgaW5kZXgsIGFuZCBkb24ndCBhZGQgdGhlIFwiLi9cIiBjaGFyYWN0ZXJzXG4gICAgICAvLyB0byB0aGUgc3RhdGUuIFRoaXMgZ3JlYXRseSBzaW1wbGlmaWVzIGxvb2tiZWhpbmRzIHdoZW5cbiAgICAgIC8vIGNoZWNraW5nIGZvciBCT1MgY2hhcmFjdGVycyBsaWtlIFwiIVwiIGFuZCBcIi5cIiAobm90IFwiLi9cIilcbiAgICAgIGlmIChwcmV2LnR5cGUgPT09ICdkb3QnICYmIHN0YXRlLmluZGV4ID09PSBzdGF0ZS5zdGFydCArIDEpIHtcbiAgICAgICAgc3RhdGUuc3RhcnQgPSBzdGF0ZS5pbmRleCArIDE7XG4gICAgICAgIHN0YXRlLmNvbnN1bWVkID0gJyc7XG4gICAgICAgIHN0YXRlLm91dHB1dCA9ICcnO1xuICAgICAgICB0b2tlbnMucG9wKCk7XG4gICAgICAgIHByZXYgPSBib3M7IC8vIHJlc2V0IFwicHJldlwiIHRvIHRoZSBmaXJzdCB0b2tlblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICdzbGFzaCcsIHZhbHVlLCBvdXRwdXQ6IFNMQVNIX0xJVEVSQUwgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb3RzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICcuJykge1xuICAgICAgaWYgKHN0YXRlLmJyYWNlcyA+IDAgJiYgcHJldi50eXBlID09PSAnZG90Jykge1xuICAgICAgICBpZiAocHJldi52YWx1ZSA9PT0gJy4nKSBwcmV2Lm91dHB1dCA9IERPVF9MSVRFUkFMO1xuICAgICAgICBjb25zdCBicmFjZSA9IGJyYWNlc1ticmFjZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHByZXYudHlwZSA9ICdkb3RzJztcbiAgICAgICAgcHJldi5vdXRwdXQgKz0gdmFsdWU7XG4gICAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG4gICAgICAgIGJyYWNlLmRvdHMgPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKChzdGF0ZS5icmFjZXMgKyBzdGF0ZS5wYXJlbnMpID09PSAwICYmIHByZXYudHlwZSAhPT0gJ2JvcycgJiYgcHJldi50eXBlICE9PSAnc2xhc2gnKSB7XG4gICAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlLCBvdXRwdXQ6IERPVF9MSVRFUkFMIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICdkb3QnLCB2YWx1ZSwgb3V0cHV0OiBET1RfTElURVJBTCB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFF1ZXN0aW9uIG1hcmtzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICc/Jykge1xuICAgICAgY29uc3QgaXNHcm91cCA9IHByZXYgJiYgcHJldi52YWx1ZSA9PT0gJygnO1xuICAgICAgaWYgKCFpc0dyb3VwICYmIG9wdHMubm9leHRnbG9iICE9PSB0cnVlICYmIHBlZWsoKSA9PT0gJygnICYmIHBlZWsoMikgIT09ICc/Jykge1xuICAgICAgICBleHRnbG9iT3BlbigncW1hcmsnLCB2YWx1ZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldiAmJiBwcmV2LnR5cGUgPT09ICdwYXJlbicpIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IHBlZWsoKTtcbiAgICAgICAgbGV0IG91dHB1dCA9IHZhbHVlO1xuXG4gICAgICAgIGlmIChuZXh0ID09PSAnPCcgJiYgIXV0aWxzLnN1cHBvcnRzTG9va2JlaGluZHMoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZS5qcyB2MTAgb3IgaGlnaGVyIGlzIHJlcXVpcmVkIGZvciByZWdleCBsb29rYmVoaW5kcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChwcmV2LnZhbHVlID09PSAnKCcgJiYgIS9bIT08Ol0vLnRlc3QobmV4dCkpIHx8IChuZXh0ID09PSAnPCcgJiYgIS88KFshPV18XFx3Kz4pLy50ZXN0KHJlbWFpbmluZygpKSkpIHtcbiAgICAgICAgICBvdXRwdXQgPSBgXFxcXCR7dmFsdWV9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlLCBvdXRwdXQgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0cy5kb3QgIT09IHRydWUgJiYgKHByZXYudHlwZSA9PT0gJ3NsYXNoJyB8fCBwcmV2LnR5cGUgPT09ICdib3MnKSkge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3FtYXJrJywgdmFsdWUsIG91dHB1dDogUU1BUktfTk9fRE9UIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICdxbWFyaycsIHZhbHVlLCBvdXRwdXQ6IFFNQVJLIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhjbGFtYXRpb25cbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJyEnKSB7XG4gICAgICBpZiAob3B0cy5ub2V4dGdsb2IgIT09IHRydWUgJiYgcGVlaygpID09PSAnKCcpIHtcbiAgICAgICAgaWYgKHBlZWsoMikgIT09ICc/JyB8fCAhL1shPTw6XS8udGVzdChwZWVrKDMpKSkge1xuICAgICAgICAgIGV4dGdsb2JPcGVuKCduZWdhdGUnLCB2YWx1ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMubm9uZWdhdGUgIT09IHRydWUgJiYgc3RhdGUuaW5kZXggPT09IDApIHtcbiAgICAgICAgbmVnYXRlKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsdXNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJysnKSB7XG4gICAgICBpZiAob3B0cy5ub2V4dGdsb2IgIT09IHRydWUgJiYgcGVlaygpID09PSAnKCcgJiYgcGVlaygyKSAhPT0gJz8nKSB7XG4gICAgICAgIGV4dGdsb2JPcGVuKCdwbHVzJywgdmFsdWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKChwcmV2ICYmIHByZXYudmFsdWUgPT09ICcoJykgfHwgb3B0cy5yZWdleCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICdwbHVzJywgdmFsdWUsIG91dHB1dDogUExVU19MSVRFUkFMIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKChwcmV2ICYmIChwcmV2LnR5cGUgPT09ICdicmFja2V0JyB8fCBwcmV2LnR5cGUgPT09ICdwYXJlbicgfHwgcHJldi50eXBlID09PSAnYnJhY2UnKSkgfHwgc3RhdGUucGFyZW5zID4gMCkge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3BsdXMnLCB2YWx1ZSB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAncGx1cycsIHZhbHVlOiBQTFVTX0xJVEVSQUwgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGFpbiB0ZXh0XG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICdAJykge1xuICAgICAgaWYgKG9wdHMubm9leHRnbG9iICE9PSB0cnVlICYmIHBlZWsoKSA9PT0gJygnICYmIHBlZWsoMikgIT09ICc/Jykge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ2F0JywgZXh0Z2xvYjogdHJ1ZSwgdmFsdWUsIG91dHB1dDogJycgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsYWluIHRleHRcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSAhPT0gJyonKSB7XG4gICAgICBpZiAodmFsdWUgPT09ICckJyB8fCB2YWx1ZSA9PT0gJ14nKSB7XG4gICAgICAgIHZhbHVlID0gYFxcXFwke3ZhbHVlfWA7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1hdGNoID0gUkVHRVhfTk9OX1NQRUNJQUxfQ0hBUlMuZXhlYyhyZW1haW5pbmcoKSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFsdWUgKz0gbWF0Y2hbMF07XG4gICAgICAgIHN0YXRlLmluZGV4ICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFyc1xuICAgICAqL1xuXG4gICAgaWYgKHByZXYgJiYgKHByZXYudHlwZSA9PT0gJ2dsb2JzdGFyJyB8fCBwcmV2LnN0YXIgPT09IHRydWUpKSB7XG4gICAgICBwcmV2LnR5cGUgPSAnc3Rhcic7XG4gICAgICBwcmV2LnN0YXIgPSB0cnVlO1xuICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcbiAgICAgIHByZXYub3V0cHV0ID0gc3RhcjtcbiAgICAgIHN0YXRlLmJhY2t0cmFjayA9IHRydWU7XG4gICAgICBzdGF0ZS5nbG9ic3RhciA9IHRydWU7XG4gICAgICBjb25zdW1lKHZhbHVlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCByZXN0ID0gcmVtYWluaW5nKCk7XG4gICAgaWYgKG9wdHMubm9leHRnbG9iICE9PSB0cnVlICYmIC9eXFwoW14/XS8udGVzdChyZXN0KSkge1xuICAgICAgZXh0Z2xvYk9wZW4oJ3N0YXInLCB2YWx1ZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocHJldi50eXBlID09PSAnc3RhcicpIHtcbiAgICAgIGlmIChvcHRzLm5vZ2xvYnN0YXIgPT09IHRydWUpIHtcbiAgICAgICAgY29uc3VtZSh2YWx1ZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcmlvciA9IHByZXYucHJldjtcbiAgICAgIGNvbnN0IGJlZm9yZSA9IHByaW9yLnByZXY7XG4gICAgICBjb25zdCBpc1N0YXJ0ID0gcHJpb3IudHlwZSA9PT0gJ3NsYXNoJyB8fCBwcmlvci50eXBlID09PSAnYm9zJztcbiAgICAgIGNvbnN0IGFmdGVyU3RhciA9IGJlZm9yZSAmJiAoYmVmb3JlLnR5cGUgPT09ICdzdGFyJyB8fCBiZWZvcmUudHlwZSA9PT0gJ2dsb2JzdGFyJyk7XG5cbiAgICAgIGlmIChvcHRzLmJhc2ggPT09IHRydWUgJiYgKCFpc1N0YXJ0IHx8IChyZXN0WzBdICYmIHJlc3RbMF0gIT09ICcvJykpKSB7XG4gICAgICAgIHB1c2goeyB0eXBlOiAnc3RhcicsIHZhbHVlLCBvdXRwdXQ6ICcnIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNCcmFjZSA9IHN0YXRlLmJyYWNlcyA+IDAgJiYgKHByaW9yLnR5cGUgPT09ICdjb21tYScgfHwgcHJpb3IudHlwZSA9PT0gJ2JyYWNlJyk7XG4gICAgICBjb25zdCBpc0V4dGdsb2IgPSBleHRnbG9icy5sZW5ndGggJiYgKHByaW9yLnR5cGUgPT09ICdwaXBlJyB8fCBwcmlvci50eXBlID09PSAncGFyZW4nKTtcbiAgICAgIGlmICghaXNTdGFydCAmJiBwcmlvci50eXBlICE9PSAncGFyZW4nICYmICFpc0JyYWNlICYmICFpc0V4dGdsb2IpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICdzdGFyJywgdmFsdWUsIG91dHB1dDogJycgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBzdHJpcCBjb25zZWN1dGl2ZSBgLyoqL2BcbiAgICAgIHdoaWxlIChyZXN0LnNsaWNlKDAsIDMpID09PSAnLyoqJykge1xuICAgICAgICBjb25zdCBhZnRlciA9IGlucHV0W3N0YXRlLmluZGV4ICsgNF07XG4gICAgICAgIGlmIChhZnRlciAmJiBhZnRlciAhPT0gJy8nKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoMyk7XG4gICAgICAgIGNvbnN1bWUoJy8qKicsIDMpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJpb3IudHlwZSA9PT0gJ2JvcycgJiYgZW9zKCkpIHtcbiAgICAgICAgcHJldi50eXBlID0gJ2dsb2JzdGFyJztcbiAgICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcbiAgICAgICAgcHJldi5vdXRwdXQgPSBnbG9ic3RhcihvcHRzKTtcbiAgICAgICAgc3RhdGUub3V0cHV0ID0gcHJldi5vdXRwdXQ7XG4gICAgICAgIHN0YXRlLmdsb2JzdGFyID0gdHJ1ZTtcbiAgICAgICAgY29uc3VtZSh2YWx1ZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJpb3IudHlwZSA9PT0gJ3NsYXNoJyAmJiBwcmlvci5wcmV2LnR5cGUgIT09ICdib3MnICYmICFhZnRlclN0YXIgJiYgZW9zKCkpIHtcbiAgICAgICAgc3RhdGUub3V0cHV0ID0gc3RhdGUub3V0cHV0LnNsaWNlKDAsIC0ocHJpb3Iub3V0cHV0ICsgcHJldi5vdXRwdXQpLmxlbmd0aCk7XG4gICAgICAgIHByaW9yLm91dHB1dCA9IGAoPzoke3ByaW9yLm91dHB1dH1gO1xuXG4gICAgICAgIHByZXYudHlwZSA9ICdnbG9ic3Rhcic7XG4gICAgICAgIHByZXYub3V0cHV0ID0gZ2xvYnN0YXIob3B0cykgKyAob3B0cy5zdHJpY3RTbGFzaGVzID8gJyknIDogJ3wkKScpO1xuICAgICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuICAgICAgICBzdGF0ZS5nbG9ic3RhciA9IHRydWU7XG4gICAgICAgIHN0YXRlLm91dHB1dCArPSBwcmlvci5vdXRwdXQgKyBwcmV2Lm91dHB1dDtcbiAgICAgICAgY29uc3VtZSh2YWx1ZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJpb3IudHlwZSA9PT0gJ3NsYXNoJyAmJiBwcmlvci5wcmV2LnR5cGUgIT09ICdib3MnICYmIHJlc3RbMF0gPT09ICcvJykge1xuICAgICAgICBjb25zdCBlbmQgPSByZXN0WzFdICE9PSB2b2lkIDAgPyAnfCQnIDogJyc7XG5cbiAgICAgICAgc3RhdGUub3V0cHV0ID0gc3RhdGUub3V0cHV0LnNsaWNlKDAsIC0ocHJpb3Iub3V0cHV0ICsgcHJldi5vdXRwdXQpLmxlbmd0aCk7XG4gICAgICAgIHByaW9yLm91dHB1dCA9IGAoPzoke3ByaW9yLm91dHB1dH1gO1xuXG4gICAgICAgIHByZXYudHlwZSA9ICdnbG9ic3Rhcic7XG4gICAgICAgIHByZXYub3V0cHV0ID0gYCR7Z2xvYnN0YXIob3B0cyl9JHtTTEFTSF9MSVRFUkFMfXwke1NMQVNIX0xJVEVSQUx9JHtlbmR9KWA7XG4gICAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG5cbiAgICAgICAgc3RhdGUub3V0cHV0ICs9IHByaW9yLm91dHB1dCArIHByZXYub3V0cHV0O1xuICAgICAgICBzdGF0ZS5nbG9ic3RhciA9IHRydWU7XG5cbiAgICAgICAgY29uc3VtZSh2YWx1ZSArIGFkdmFuY2UoKSk7XG5cbiAgICAgICAgcHVzaCh7IHR5cGU6ICdzbGFzaCcsIHZhbHVlOiAnLycsIG91dHB1dDogJycgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJpb3IudHlwZSA9PT0gJ2JvcycgJiYgcmVzdFswXSA9PT0gJy8nKSB7XG4gICAgICAgIHByZXYudHlwZSA9ICdnbG9ic3Rhcic7XG4gICAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG4gICAgICAgIHByZXYub3V0cHV0ID0gYCg/Ol58JHtTTEFTSF9MSVRFUkFMfXwke2dsb2JzdGFyKG9wdHMpfSR7U0xBU0hfTElURVJBTH0pYDtcbiAgICAgICAgc3RhdGUub3V0cHV0ID0gcHJldi5vdXRwdXQ7XG4gICAgICAgIHN0YXRlLmdsb2JzdGFyID0gdHJ1ZTtcbiAgICAgICAgY29uc3VtZSh2YWx1ZSArIGFkdmFuY2UoKSk7XG4gICAgICAgIHB1c2goeyB0eXBlOiAnc2xhc2gnLCB2YWx1ZTogJy8nLCBvdXRwdXQ6ICcnIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIHNpbmdsZSBzdGFyIGZyb20gb3V0cHV0XG4gICAgICBzdGF0ZS5vdXRwdXQgPSBzdGF0ZS5vdXRwdXQuc2xpY2UoMCwgLXByZXYub3V0cHV0Lmxlbmd0aCk7XG5cbiAgICAgIC8vIHJlc2V0IHByZXZpb3VzIHRva2VuIHRvIGdsb2JzdGFyXG4gICAgICBwcmV2LnR5cGUgPSAnZ2xvYnN0YXInO1xuICAgICAgcHJldi5vdXRwdXQgPSBnbG9ic3RhcihvcHRzKTtcbiAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG5cbiAgICAgIC8vIHJlc2V0IG91dHB1dCB3aXRoIGdsb2JzdGFyXG4gICAgICBzdGF0ZS5vdXRwdXQgKz0gcHJldi5vdXRwdXQ7XG4gICAgICBzdGF0ZS5nbG9ic3RhciA9IHRydWU7XG4gICAgICBjb25zdW1lKHZhbHVlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHRva2VuID0geyB0eXBlOiAnc3RhcicsIHZhbHVlLCBvdXRwdXQ6IHN0YXIgfTtcblxuICAgIGlmIChvcHRzLmJhc2ggPT09IHRydWUpIHtcbiAgICAgIHRva2VuLm91dHB1dCA9ICcuKj8nO1xuICAgICAgaWYgKHByZXYudHlwZSA9PT0gJ2JvcycgfHwgcHJldi50eXBlID09PSAnc2xhc2gnKSB7XG4gICAgICAgIHRva2VuLm91dHB1dCA9IG5vZG90ICsgdG9rZW4ub3V0cHV0O1xuICAgICAgfVxuICAgICAgcHVzaCh0b2tlbik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocHJldiAmJiAocHJldi50eXBlID09PSAnYnJhY2tldCcgfHwgcHJldi50eXBlID09PSAncGFyZW4nKSAmJiBvcHRzLnJlZ2V4ID09PSB0cnVlKSB7XG4gICAgICB0b2tlbi5vdXRwdXQgPSB2YWx1ZTtcbiAgICAgIHB1c2godG9rZW4pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmluZGV4ID09PSBzdGF0ZS5zdGFydCB8fCBwcmV2LnR5cGUgPT09ICdzbGFzaCcgfHwgcHJldi50eXBlID09PSAnZG90Jykge1xuICAgICAgaWYgKHByZXYudHlwZSA9PT0gJ2RvdCcpIHtcbiAgICAgICAgc3RhdGUub3V0cHV0ICs9IE5PX0RPVF9TTEFTSDtcbiAgICAgICAgcHJldi5vdXRwdXQgKz0gTk9fRE9UX1NMQVNIO1xuXG4gICAgICB9IGVsc2UgaWYgKG9wdHMuZG90ID09PSB0cnVlKSB7XG4gICAgICAgIHN0YXRlLm91dHB1dCArPSBOT19ET1RTX1NMQVNIO1xuICAgICAgICBwcmV2Lm91dHB1dCArPSBOT19ET1RTX1NMQVNIO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5vdXRwdXQgKz0gbm9kb3Q7XG4gICAgICAgIHByZXYub3V0cHV0ICs9IG5vZG90O1xuICAgICAgfVxuXG4gICAgICBpZiAocGVlaygpICE9PSAnKicpIHtcbiAgICAgICAgc3RhdGUub3V0cHV0ICs9IE9ORV9DSEFSO1xuICAgICAgICBwcmV2Lm91dHB1dCArPSBPTkVfQ0hBUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwdXNoKHRva2VuKTtcbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5icmFja2V0cyA+IDApIHtcbiAgICBpZiAob3B0cy5zdHJpY3RCcmFja2V0cyA9PT0gdHJ1ZSkgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKCdjbG9zaW5nJywgJ10nKSk7XG4gICAgc3RhdGUub3V0cHV0ID0gdXRpbHMuZXNjYXBlTGFzdChzdGF0ZS5vdXRwdXQsICdbJyk7XG4gICAgZGVjcmVtZW50KCdicmFja2V0cycpO1xuICB9XG5cbiAgd2hpbGUgKHN0YXRlLnBhcmVucyA+IDApIHtcbiAgICBpZiAob3B0cy5zdHJpY3RCcmFja2V0cyA9PT0gdHJ1ZSkgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKCdjbG9zaW5nJywgJyknKSk7XG4gICAgc3RhdGUub3V0cHV0ID0gdXRpbHMuZXNjYXBlTGFzdChzdGF0ZS5vdXRwdXQsICcoJyk7XG4gICAgZGVjcmVtZW50KCdwYXJlbnMnKTtcbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5icmFjZXMgPiAwKSB7XG4gICAgaWYgKG9wdHMuc3RyaWN0QnJhY2tldHMgPT09IHRydWUpIHRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcignY2xvc2luZycsICd9JykpO1xuICAgIHN0YXRlLm91dHB1dCA9IHV0aWxzLmVzY2FwZUxhc3Qoc3RhdGUub3V0cHV0LCAneycpO1xuICAgIGRlY3JlbWVudCgnYnJhY2VzJyk7XG4gIH1cblxuICBpZiAob3B0cy5zdHJpY3RTbGFzaGVzICE9PSB0cnVlICYmIChwcmV2LnR5cGUgPT09ICdzdGFyJyB8fCBwcmV2LnR5cGUgPT09ICdicmFja2V0JykpIHtcbiAgICBwdXNoKHsgdHlwZTogJ21heWJlX3NsYXNoJywgdmFsdWU6ICcnLCBvdXRwdXQ6IGAke1NMQVNIX0xJVEVSQUx9P2AgfSk7XG4gIH1cblxuICAvLyByZWJ1aWxkIHRoZSBvdXRwdXQgaWYgd2UgaGFkIHRvIGJhY2t0cmFjayBhdCBhbnkgcG9pbnRcbiAgaWYgKHN0YXRlLmJhY2t0cmFjayA9PT0gdHJ1ZSkge1xuICAgIHN0YXRlLm91dHB1dCA9ICcnO1xuXG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiBzdGF0ZS50b2tlbnMpIHtcbiAgICAgIHN0YXRlLm91dHB1dCArPSB0b2tlbi5vdXRwdXQgIT0gbnVsbCA/IHRva2VuLm91dHB1dCA6IHRva2VuLnZhbHVlO1xuXG4gICAgICBpZiAodG9rZW4uc3VmZml4KSB7XG4gICAgICAgIHN0YXRlLm91dHB1dCArPSB0b2tlbi5zdWZmaXg7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufTtcblxuLyoqXG4gKiBGYXN0IHBhdGhzIGZvciBjcmVhdGluZyByZWd1bGFyIGV4cHJlc3Npb25zIGZvciBjb21tb24gZ2xvYiBwYXR0ZXJucy5cbiAqIFRoaXMgY2FuIHNpZ25pZmljYW50bHkgc3BlZWQgdXAgcHJvY2Vzc2luZyBhbmQgaGFzIHZlcnkgbGl0dGxlIGRvd25zaWRlXG4gKiBpbXBhY3Qgd2hlbiBub25lIG9mIHRoZSBmYXN0IHBhdGhzIG1hdGNoLlxuICovXG5cbnBhcnNlLmZhc3RwYXRocyA9IChpbnB1dCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBvcHRzID0geyAuLi5vcHRpb25zIH07XG4gIGNvbnN0IG1heCA9IHR5cGVvZiBvcHRzLm1heExlbmd0aCA9PT0gJ251bWJlcicgPyBNYXRoLm1pbihNQVhfTEVOR1RILCBvcHRzLm1heExlbmd0aCkgOiBNQVhfTEVOR1RIO1xuICBjb25zdCBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gIGlmIChsZW4gPiBtYXgpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtsZW59LCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBsZW5ndGg6ICR7bWF4fWApO1xuICB9XG5cbiAgaW5wdXQgPSBSRVBMQUNFTUVOVFNbaW5wdXRdIHx8IGlucHV0O1xuICBjb25zdCB3aW4zMiA9IHV0aWxzLmlzV2luZG93cyhvcHRpb25zKTtcblxuICAvLyBjcmVhdGUgY29uc3RhbnRzIGJhc2VkIG9uIHBsYXRmb3JtLCBmb3Igd2luZG93cyBvciBwb3NpeFxuICBjb25zdCB7XG4gICAgRE9UX0xJVEVSQUwsXG4gICAgU0xBU0hfTElURVJBTCxcbiAgICBPTkVfQ0hBUixcbiAgICBET1RTX1NMQVNILFxuICAgIE5PX0RPVCxcbiAgICBOT19ET1RTLFxuICAgIE5PX0RPVFNfU0xBU0gsXG4gICAgU1RBUixcbiAgICBTVEFSVF9BTkNIT1JcbiAgfSA9IGNvbnN0YW50cy5nbG9iQ2hhcnMod2luMzIpO1xuXG4gIGNvbnN0IG5vZG90ID0gb3B0cy5kb3QgPyBOT19ET1RTIDogTk9fRE9UO1xuICBjb25zdCBzbGFzaERvdCA9IG9wdHMuZG90ID8gTk9fRE9UU19TTEFTSCA6IE5PX0RPVDtcbiAgY29uc3QgY2FwdHVyZSA9IG9wdHMuY2FwdHVyZSA/ICcnIDogJz86JztcbiAgY29uc3Qgc3RhdGUgPSB7IG5lZ2F0ZWQ6IGZhbHNlLCBwcmVmaXg6ICcnIH07XG4gIGxldCBzdGFyID0gb3B0cy5iYXNoID09PSB0cnVlID8gJy4qPycgOiBTVEFSO1xuXG4gIGlmIChvcHRzLmNhcHR1cmUpIHtcbiAgICBzdGFyID0gYCgke3N0YXJ9KWA7XG4gIH1cblxuICBjb25zdCBnbG9ic3RhciA9IG9wdHMgPT4ge1xuICAgIGlmIChvcHRzLm5vZ2xvYnN0YXIgPT09IHRydWUpIHJldHVybiBzdGFyO1xuICAgIHJldHVybiBgKCR7Y2FwdHVyZX0oPzooPyEke1NUQVJUX0FOQ0hPUn0ke29wdHMuZG90ID8gRE9UU19TTEFTSCA6IERPVF9MSVRFUkFMfSkuKSo/KWA7XG4gIH07XG5cbiAgY29uc3QgY3JlYXRlID0gc3RyID0+IHtcbiAgICBzd2l0Y2ggKHN0cikge1xuICAgICAgY2FzZSAnKic6XG4gICAgICAgIHJldHVybiBgJHtub2RvdH0ke09ORV9DSEFSfSR7c3Rhcn1gO1xuXG4gICAgICBjYXNlICcuKic6XG4gICAgICAgIHJldHVybiBgJHtET1RfTElURVJBTH0ke09ORV9DSEFSfSR7c3Rhcn1gO1xuXG4gICAgICBjYXNlICcqLionOlxuICAgICAgICByZXR1cm4gYCR7bm9kb3R9JHtzdGFyfSR7RE9UX0xJVEVSQUx9JHtPTkVfQ0hBUn0ke3N0YXJ9YDtcblxuICAgICAgY2FzZSAnKi8qJzpcbiAgICAgICAgcmV0dXJuIGAke25vZG90fSR7c3Rhcn0ke1NMQVNIX0xJVEVSQUx9JHtPTkVfQ0hBUn0ke3NsYXNoRG90fSR7c3Rhcn1gO1xuXG4gICAgICBjYXNlICcqKic6XG4gICAgICAgIHJldHVybiBub2RvdCArIGdsb2JzdGFyKG9wdHMpO1xuXG4gICAgICBjYXNlICcqKi8qJzpcbiAgICAgICAgcmV0dXJuIGAoPzoke25vZG90fSR7Z2xvYnN0YXIob3B0cyl9JHtTTEFTSF9MSVRFUkFMfSk/JHtzbGFzaERvdH0ke09ORV9DSEFSfSR7c3Rhcn1gO1xuXG4gICAgICBjYXNlICcqKi8qLionOlxuICAgICAgICByZXR1cm4gYCg/OiR7bm9kb3R9JHtnbG9ic3RhcihvcHRzKX0ke1NMQVNIX0xJVEVSQUx9KT8ke3NsYXNoRG90fSR7c3Rhcn0ke0RPVF9MSVRFUkFMfSR7T05FX0NIQVJ9JHtzdGFyfWA7XG5cbiAgICAgIGNhc2UgJyoqLy4qJzpcbiAgICAgICAgcmV0dXJuIGAoPzoke25vZG90fSR7Z2xvYnN0YXIob3B0cyl9JHtTTEFTSF9MSVRFUkFMfSk/JHtET1RfTElURVJBTH0ke09ORV9DSEFSfSR7c3Rhcn1gO1xuXG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gL14oLio/KVxcLihcXHcrKSQvLmV4ZWMoc3RyKTtcbiAgICAgICAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGNyZWF0ZShtYXRjaFsxXSk7XG4gICAgICAgIGlmICghc291cmNlKSByZXR1cm47XG5cbiAgICAgICAgcmV0dXJuIHNvdXJjZSArIERPVF9MSVRFUkFMICsgbWF0Y2hbMl07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG91dHB1dCA9IHV0aWxzLnJlbW92ZVByZWZpeChpbnB1dCwgc3RhdGUpO1xuICBsZXQgc291cmNlID0gY3JlYXRlKG91dHB1dCk7XG5cbiAgaWYgKHNvdXJjZSAmJiBvcHRzLnN0cmljdFNsYXNoZXMgIT09IHRydWUpIHtcbiAgICBzb3VyY2UgKz0gYCR7U0xBU0hfTElURVJBTH0/YDtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xuIl0sIm5hbWVzIjpbImNvbnN0YW50cyIsInJlcXVpcmUiLCJ1dGlscyIsIk1BWF9MRU5HVEgiLCJQT1NJWF9SRUdFWF9TT1VSQ0UiLCJSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUyIsIlJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRiIsIlJFUExBQ0VNRU5UUyIsImV4cGFuZFJhbmdlIiwiYXJncyIsIm9wdGlvbnMiLCJzb3J0IiwidmFsdWUiLCJqb2luIiwiUmVnRXhwIiwiZXgiLCJtYXAiLCJ2IiwiZXNjYXBlUmVnZXgiLCJzeW50YXhFcnJvciIsInR5cGUiLCJjaGFyIiwicGFyc2UiLCJpbnB1dCIsIlR5cGVFcnJvciIsIm9wdHMiLCJtYXgiLCJtYXhMZW5ndGgiLCJNYXRoIiwibWluIiwibGVuIiwibGVuZ3RoIiwiU3ludGF4RXJyb3IiLCJib3MiLCJvdXRwdXQiLCJwcmVwZW5kIiwidG9rZW5zIiwiY2FwdHVyZSIsIndpbjMyIiwiaXNXaW5kb3dzIiwiUExBVEZPUk1fQ0hBUlMiLCJnbG9iQ2hhcnMiLCJFWFRHTE9CX0NIQVJTIiwiZXh0Z2xvYkNoYXJzIiwiRE9UX0xJVEVSQUwiLCJQTFVTX0xJVEVSQUwiLCJTTEFTSF9MSVRFUkFMIiwiT05FX0NIQVIiLCJET1RTX1NMQVNIIiwiTk9fRE9UIiwiTk9fRE9UX1NMQVNIIiwiTk9fRE9UU19TTEFTSCIsIlFNQVJLIiwiUU1BUktfTk9fRE9UIiwiU1RBUiIsIlNUQVJUX0FOQ0hPUiIsImdsb2JzdGFyIiwiZG90Iiwibm9kb3QiLCJxbWFya05vRG90Iiwic3RhciIsImJhc2giLCJub2V4dCIsIm5vZXh0Z2xvYiIsInN0YXRlIiwiaW5kZXgiLCJzdGFydCIsImNvbnN1bWVkIiwicHJlZml4IiwiYmFja3RyYWNrIiwibmVnYXRlZCIsImJyYWNrZXRzIiwiYnJhY2VzIiwicGFyZW5zIiwicXVvdGVzIiwicmVtb3ZlUHJlZml4IiwiZXh0Z2xvYnMiLCJzdGFjayIsInByZXYiLCJlb3MiLCJwZWVrIiwibiIsImFkdmFuY2UiLCJyZW1haW5pbmciLCJzbGljZSIsImNvbnN1bWUiLCJudW0iLCJhcHBlbmQiLCJ0b2tlbiIsIm5lZ2F0ZSIsImNvdW50IiwiaW5jcmVtZW50IiwicHVzaCIsImRlY3JlbWVudCIsInBvcCIsInRvayIsImlzQnJhY2UiLCJpc0V4dGdsb2IiLCJleHRnbG9iIiwiaW5uZXIiLCJleHRnbG9iT3BlbiIsImNvbmRpdGlvbnMiLCJvcGVuIiwiZXh0Z2xvYkNsb3NlIiwiY2xvc2UiLCJyZXN0IiwiZXh0Z2xvYlN0YXIiLCJpbmNsdWRlcyIsInRlc3QiLCJleHByZXNzaW9uIiwiZmFzdHBhdGhzIiwibmVnYXRlZEV4dGdsb2IiLCJiYWNrc2xhc2hlcyIsInJlcGxhY2UiLCJtIiwiZXNjIiwiY2hhcnMiLCJmaXJzdCIsInJlcGVhdCIsInVuZXNjYXBlIiwiY29udGFpbnMiLCJ3cmFwT3V0cHV0IiwibmV4dCIsIm1hdGNoIiwiZXhlYyIsInNsYXNoZXMiLCJwb3NpeCIsImlkeCIsImxhc3RJbmRleE9mIiwicHJlIiwiaW5kZXhPZiIsImtlZXBRdW90ZXMiLCJzdHJpY3RCcmFja2V0cyIsIm5vYnJhY2tldCIsInByZXZWYWx1ZSIsImxpdGVyYWxCcmFja2V0cyIsImhhc1JlZ2V4Q2hhcnMiLCJlc2NhcGVkIiwibm9icmFjZSIsIm91dHB1dEluZGV4IiwidG9rZW5zSW5kZXgiLCJicmFjZSIsImRvdHMiLCJhcnIiLCJyYW5nZSIsImkiLCJ1bnNoaWZ0IiwiY29tbWEiLCJvdXQiLCJ0b2tzIiwidCIsImlzR3JvdXAiLCJzdXBwb3J0c0xvb2tiZWhpbmRzIiwiRXJyb3IiLCJub25lZ2F0ZSIsInJlZ2V4Iiwibm9nbG9ic3RhciIsInByaW9yIiwiYmVmb3JlIiwiaXNTdGFydCIsImFmdGVyU3RhciIsImFmdGVyIiwic3RyaWN0U2xhc2hlcyIsImVuZCIsImVzY2FwZUxhc3QiLCJzdWZmaXgiLCJOT19ET1RTIiwic2xhc2hEb3QiLCJjcmVhdGUiLCJzdHIiLCJzb3VyY2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst path = __webpack_require__(/*! path */ \"path\");\nconst scan = __webpack_require__(/*! ./scan */ \"(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js\");\nconst parse = __webpack_require__(/*! ./parse */ \"(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js\");\nconst constants = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js\");\nconst isObject = (val)=>val && typeof val === \"object\" && !Array.isArray(val);\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */ const picomatch = (glob, options, returnState = false)=>{\n    if (Array.isArray(glob)) {\n        const fns = glob.map((input)=>picomatch(input, options, returnState));\n        const arrayMatcher = (str)=>{\n            for (const isMatch of fns){\n                const state = isMatch(str);\n                if (state) return state;\n            }\n            return false;\n        };\n        return arrayMatcher;\n    }\n    const isState = isObject(glob) && glob.tokens && glob.input;\n    if (glob === \"\" || typeof glob !== \"string\" && !isState) {\n        throw new TypeError(\"Expected pattern to be a non-empty string\");\n    }\n    const opts = options || {};\n    const posix = utils.isWindows(options);\n    const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);\n    const state = regex.state;\n    delete regex.state;\n    let isIgnored = ()=>false;\n    if (opts.ignore) {\n        const ignoreOpts = {\n            ...options,\n            ignore: null,\n            onMatch: null,\n            onResult: null\n        };\n        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n    }\n    const matcher = (input, returnObject = false)=>{\n        const { isMatch, match, output } = picomatch.test(input, regex, options, {\n            glob,\n            posix\n        });\n        const result = {\n            glob,\n            state,\n            regex,\n            posix,\n            input,\n            output,\n            match,\n            isMatch\n        };\n        if (typeof opts.onResult === \"function\") {\n            opts.onResult(result);\n        }\n        if (isMatch === false) {\n            result.isMatch = false;\n            return returnObject ? result : false;\n        }\n        if (isIgnored(input)) {\n            if (typeof opts.onIgnore === \"function\") {\n                opts.onIgnore(result);\n            }\n            result.isMatch = false;\n            return returnObject ? result : false;\n        }\n        if (typeof opts.onMatch === \"function\") {\n            opts.onMatch(result);\n        }\n        return returnObject ? result : true;\n    };\n    if (returnState) {\n        matcher.state = state;\n    }\n    return matcher;\n};\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */ picomatch.test = (input, regex, options, { glob, posix } = {})=>{\n    if (typeof input !== \"string\") {\n        throw new TypeError(\"Expected input to be a string\");\n    }\n    if (input === \"\") {\n        return {\n            isMatch: false,\n            output: \"\"\n        };\n    }\n    const opts = options || {};\n    const format = opts.format || (posix ? utils.toPosixSlashes : null);\n    let match = input === glob;\n    let output = match && format ? format(input) : input;\n    if (match === false) {\n        output = format ? format(input) : input;\n        match = output === glob;\n    }\n    if (match === false || opts.capture === true) {\n        if (opts.matchBase === true || opts.basename === true) {\n            match = picomatch.matchBase(input, regex, options, posix);\n        } else {\n            match = regex.exec(output);\n        }\n    }\n    return {\n        isMatch: Boolean(match),\n        match,\n        output\n    };\n};\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */ picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options))=>{\n    const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n    return regex.test(path.basename(input));\n};\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */ picomatch.isMatch = (str, patterns, options)=>picomatch(patterns, options)(str);\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */ picomatch.parse = (pattern, options)=>{\n    if (Array.isArray(pattern)) return pattern.map((p)=>picomatch.parse(p, options));\n    return parse(pattern, {\n        ...options,\n        fastpaths: false\n    });\n};\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */ picomatch.scan = (input, options)=>scan(input, options);\n/**\n * Compile a regular expression from the `state` object returned by the\n * [parse()](#parse) method.\n *\n * @param {Object} `state`\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n * @return {RegExp}\n * @api public\n */ picomatch.compileRe = (state, options, returnOutput = false, returnState = false)=>{\n    if (returnOutput === true) {\n        return state.output;\n    }\n    const opts = options || {};\n    const prepend = opts.contains ? \"\" : \"^\";\n    const append = opts.contains ? \"\" : \"$\";\n    let source = `${prepend}(?:${state.output})${append}`;\n    if (state && state.negated === true) {\n        source = `^(?!${source}).*$`;\n    }\n    const regex = picomatch.toRegex(source, options);\n    if (returnState === true) {\n        regex.state = state;\n    }\n    return regex;\n};\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */ picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false)=>{\n    if (!input || typeof input !== \"string\") {\n        throw new TypeError(\"Expected a non-empty string\");\n    }\n    let parsed = {\n        negated: false,\n        fastpaths: true\n    };\n    if (options.fastpaths !== false && (input[0] === \".\" || input[0] === \"*\")) {\n        parsed.output = parse.fastpaths(input, options);\n    }\n    if (!parsed.output) {\n        parsed = parse(input, options);\n    }\n    return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */ picomatch.toRegex = (source, options)=>{\n    try {\n        const opts = options || {};\n        return new RegExp(source, opts.flags || (opts.nocase ? \"i\" : \"\"));\n    } catch (err) {\n        if (options && options.debug === true) throw err;\n        return /$^/;\n    }\n};\n/**\n * Picomatch constants.\n * @return {Object}\n */ picomatch.constants = constants;\n/**\n * Expose \"picomatch\"\n */ module.exports = picomatch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vcGljb21hdGNoQDIuMy4xL25vZGVfbW9kdWxlcy9waWNvbWF0Y2gvbGliL3BpY29tYXRjaC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLE9BQU9DLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1FLFFBQVFGLG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU1HLFFBQVFILG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU1JLFlBQVlKLG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1LLFdBQVdDLENBQUFBLE1BQU9BLE9BQU8sT0FBT0EsUUFBUSxZQUFZLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0Y7QUFFekU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBRUQsTUFBTUcsWUFBWSxDQUFDQyxNQUFNQyxTQUFTQyxjQUFjLEtBQUs7SUFDbkQsSUFBSUwsTUFBTUMsT0FBTyxDQUFDRSxPQUFPO1FBQ3ZCLE1BQU1HLE1BQU1ILEtBQUtJLEdBQUcsQ0FBQ0MsQ0FBQUEsUUFBU04sVUFBVU0sT0FBT0osU0FBU0M7UUFDeEQsTUFBTUksZUFBZUMsQ0FBQUE7WUFDbkIsS0FBSyxNQUFNQyxXQUFXTCxJQUFLO2dCQUN6QixNQUFNTSxRQUFRRCxRQUFRRDtnQkFDdEIsSUFBSUUsT0FBTyxPQUFPQTtZQUNwQjtZQUNBLE9BQU87UUFDVDtRQUNBLE9BQU9IO0lBQ1Q7SUFFQSxNQUFNSSxVQUFVZixTQUFTSyxTQUFTQSxLQUFLVyxNQUFNLElBQUlYLEtBQUtLLEtBQUs7SUFFM0QsSUFBSUwsU0FBUyxNQUFPLE9BQU9BLFNBQVMsWUFBWSxDQUFDVSxTQUFVO1FBQ3pELE1BQU0sSUFBSUUsVUFBVTtJQUN0QjtJQUVBLE1BQU1DLE9BQU9aLFdBQVcsQ0FBQztJQUN6QixNQUFNYSxRQUFRckIsTUFBTXNCLFNBQVMsQ0FBQ2Q7SUFDOUIsTUFBTWUsUUFBUU4sVUFDVlgsVUFBVWtCLFNBQVMsQ0FBQ2pCLE1B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LE1BQU1EO1FBQzdDLE9BQU87SUFDVDtBQUNGO0FBRUE7OztDQUdDLEdBRUR0RCxVQUFVTCxTQUFTLEdBQUdBO0FBRXRCOztDQUVDLEdBRUQ2RCxPQUFPQyxPQUFPLEdBQUd6RCIsInNvdXJjZXMiOlsid2VicGFjazovL3RhaWx3aW5kdWktc3R1ZGlvLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpY29tYXRjaEAyLjMuMS9ub2RlX21vZHVsZXMvcGljb21hdGNoL2xpYi9waWNvbWF0Y2guanM/MThhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBzY2FuID0gcmVxdWlyZSgnLi9zY2FuJyk7XG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IGlzT2JqZWN0ID0gdmFsID0+IHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWwpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRjaGVyIGZ1bmN0aW9uIGZyb20gb25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucy4gVGhlXG4gKiByZXR1cm5lZCBmdW5jdGlvbiB0YWtlcyBhIHN0cmluZyB0byBtYXRjaCBhcyBpdHMgZmlyc3QgYXJndW1lbnQsXG4gKiBhbmQgcmV0dXJucyB0cnVlIGlmIHRoZSBzdHJpbmcgaXMgYSBtYXRjaC4gVGhlIHJldHVybmVkIG1hdGNoZXJcbiAqIGZ1bmN0aW9uIGFsc28gdGFrZXMgYSBib29sZWFuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdGhhdCwgd2hlbiB0cnVlLFxuICogcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwaWNvbWF0Y2ggPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcbiAqIC8vIHBpY29tYXRjaChnbG9iWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnN0IGlzTWF0Y2ggPSBwaWNvbWF0Y2goJyouISgqYSknKTtcbiAqIGNvbnNvbGUubG9nKGlzTWF0Y2goJ2EuYScpKTsgLy89PiBmYWxzZVxuICogY29uc29sZS5sb2coaXNNYXRjaCgnYS5iJykpOyAvLz0+IHRydWVcbiAqIGBgYFxuICogQG5hbWUgcGljb21hdGNoXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYGdsb2JzYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zLlxuICogQHBhcmFtIHtPYmplY3Q9fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge0Z1bmN0aW9uPX0gUmV0dXJucyBhIG1hdGNoZXIgZnVuY3Rpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmNvbnN0IHBpY29tYXRjaCA9IChnbG9iLCBvcHRpb25zLCByZXR1cm5TdGF0ZSA9IGZhbHNlKSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KGdsb2IpKSB7XG4gICAgY29uc3QgZm5zID0gZ2xvYi5tYXAoaW5wdXQgPT4gcGljb21hdGNoKGlucHV0LCBvcHRpb25zLCByZXR1cm5TdGF0ZSkpO1xuICAgIGNvbnN0IGFycmF5TWF0Y2hlciA9IHN0ciA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGlzTWF0Y2ggb2YgZm5zKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gaXNNYXRjaChzdHIpO1xuICAgICAgICBpZiAoc3RhdGUpIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBhcnJheU1hdGNoZXI7XG4gIH1cblxuICBjb25zdCBpc1N0YXRlID0gaXNPYmplY3QoZ2xvYikgJiYgZ2xvYi50b2tlbnMgJiYgZ2xvYi5pbnB1dDtcblxuICBpZiAoZ2xvYiA9PT0gJycgfHwgKHR5cGVvZiBnbG9iICE9PSAnc3RyaW5nJyAmJiAhaXNTdGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICB9XG5cbiAgY29uc3Qgb3B0cyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHBvc2l4ID0gdXRpbHMuaXNXaW5kb3dzKG9wdGlvbnMpO1xuICBjb25zdCByZWdleCA9IGlzU3RhdGVcbiAgICA/IHBpY29tYXRjaC5jb21waWxlUmUoZ2xvYiwgb3B0aW9ucylcbiAgICA6IHBpY29tYXRjaC5tYWtlUmUoZ2xvYiwgb3B0aW9ucywgZmFsc2UsIHRydWUpO1xuXG4gIGNvbnN0IHN0YXRlID0gcmVnZXguc3RhdGU7XG4gIGRlbGV0ZSByZWdleC5zdGF0ZTtcblxuICBsZXQgaXNJZ25vcmVkID0gKCkgPT4gZmFsc2U7XG4gIGlmIChvcHRzLmlnbm9yZSkge1xuICAgIGNvbnN0IGlnbm9yZU9wdHMgPSB7IC4uLm9wdGlvbnMsIGlnbm9yZTogbnVsbCwgb25NYXRjaDogbnVsbCwgb25SZXN1bHQ6IG51bGwgfTtcbiAgICBpc0lnbm9yZWQgPSBwaWNvbWF0Y2gob3B0cy5pZ25vcmUsIGlnbm9yZU9wdHMsIHJldHVyblN0YXRlKTtcbiAgfVxuXG4gIGNvbnN0IG1hdGNoZXIgPSAoaW5wdXQsIHJldHVybk9iamVjdCA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgeyBpc01hdGNoLCBtYXRjaCwgb3V0cHV0IH0gPSBwaWNvbWF0Y2gudGVzdChpbnB1dCwgcmVnZXgsIG9wdGlvbnMsIHsgZ2xvYiwgcG9zaXggfSk7XG4gICAgY29uc3QgcmVzdWx0ID0geyBnbG9iLCBzdGF0ZSwgcmVnZXgsIHBvc2l4LCBpbnB1dCwgb3V0cHV0LCBtYXRjaCwgaXNNYXRjaCB9O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRzLm9uUmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRzLm9uUmVzdWx0KHJlc3VsdCk7XG4gICAgfVxuXG4gICAgaWYgKGlzTWF0Y2ggPT09IGZhbHNlKSB7XG4gICAgICByZXN1bHQuaXNNYXRjaCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHJldHVybk9iamVjdCA/IHJlc3VsdCA6IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpc0lnbm9yZWQoaW5wdXQpKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdHMub25JZ25vcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0cy5vbklnbm9yZShyZXN1bHQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmlzTWF0Y2ggPSBmYWxzZTtcbiAgICAgIHJldHVybiByZXR1cm5PYmplY3QgPyByZXN1bHQgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdHMub25NYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3B0cy5vbk1hdGNoKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5PYmplY3QgPyByZXN1bHQgOiB0cnVlO1xuICB9O1xuXG4gIGlmIChyZXR1cm5TdGF0ZSkge1xuICAgIG1hdGNoZXIuc3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVyO1xufTtcblxuLyoqXG4gKiBUZXN0IGBpbnB1dGAgd2l0aCB0aGUgZ2l2ZW4gYHJlZ2V4YC4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBtYWluXG4gKiBgcGljb21hdGNoKClgIGZ1bmN0aW9uIHRvIHRlc3QgdGhlIGlucHV0IHN0cmluZy5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcGljb21hdGNoID0gcmVxdWlyZSgncGljb21hdGNoJyk7XG4gKiAvLyBwaWNvbWF0Y2gudGVzdChpbnB1dCwgcmVnZXhbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cocGljb21hdGNoLnRlc3QoJ2Zvby9iYXInLCAvXig/OihbXi9dKj8pXFwvKFteL10qPykpJC8pKTtcbiAqIC8vIHsgaXNNYXRjaDogdHJ1ZSwgbWF0Y2g6IFsgJ2Zvby8nLCAnZm9vJywgJ2JhcicgXSwgb3V0cHV0OiAnZm9vL2JhcicgfVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYGlucHV0YCBTdHJpbmcgdG8gdGVzdC5cbiAqIEBwYXJhbSB7UmVnRXhwfSBgcmVnZXhgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGggbWF0Y2hpbmcgaW5mby5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucGljb21hdGNoLnRlc3QgPSAoaW5wdXQsIHJlZ2V4LCBvcHRpb25zLCB7IGdsb2IsIHBvc2l4IH0gPSB7fSkgPT4ge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGlucHV0IHRvIGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAoaW5wdXQgPT09ICcnKSB7XG4gICAgcmV0dXJuIHsgaXNNYXRjaDogZmFsc2UsIG91dHB1dDogJycgfTtcbiAgfVxuXG4gIGNvbnN0IG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBmb3JtYXQgPSBvcHRzLmZvcm1hdCB8fCAocG9zaXggPyB1dGlscy50b1Bvc2l4U2xhc2hlcyA6IG51bGwpO1xuICBsZXQgbWF0Y2ggPSBpbnB1dCA9PT0gZ2xvYjtcbiAgbGV0IG91dHB1dCA9IChtYXRjaCAmJiBmb3JtYXQpID8gZm9ybWF0KGlucHV0KSA6IGlucHV0O1xuXG4gIGlmIChtYXRjaCA9PT0gZmFsc2UpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXQgPyBmb3JtYXQoaW5wdXQpIDogaW5wdXQ7XG4gICAgbWF0Y2ggPSBvdXRwdXQgPT09IGdsb2I7XG4gIH1cblxuICBpZiAobWF0Y2ggPT09IGZhbHNlIHx8IG9wdHMuY2FwdHVyZSA9PT0gdHJ1ZSkge1xuICAgIGlmIChvcHRzLm1hdGNoQmFzZSA9PT0gdHJ1ZSB8fCBvcHRzLmJhc2VuYW1lID09PSB0cnVlKSB7XG4gICAgICBtYXRjaCA9IHBpY29tYXRjaC5tYXRjaEJhc2UoaW5wdXQsIHJlZ2V4LCBvcHRpb25zLCBwb3NpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGNoID0gcmVnZXguZXhlYyhvdXRwdXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGlzTWF0Y2g6IEJvb2xlYW4obWF0Y2gpLCBtYXRjaCwgb3V0cHV0IH07XG59O1xuXG4vKipcbiAqIE1hdGNoIHRoZSBiYXNlbmFtZSBvZiBhIGZpbGVwYXRoLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwaWNvbWF0Y2ggPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcbiAqIC8vIHBpY29tYXRjaC5tYXRjaEJhc2UoaW5wdXQsIGdsb2JbLCBvcHRpb25zXSk7XG4gKiBjb25zb2xlLmxvZyhwaWNvbWF0Y2gubWF0Y2hCYXNlKCdmb28vYmFyLmpzJywgJyouanMnKTsgLy8gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYGlucHV0YCBTdHJpbmcgdG8gdGVzdC5cbiAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gYGdsb2JgIEdsb2IgcGF0dGVybiBvciByZWdleCBjcmVhdGVkIGJ5IFsubWFrZVJlXSgjbWFrZVJlKS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBpY29tYXRjaC5tYXRjaEJhc2UgPSAoaW5wdXQsIGdsb2IsIG9wdGlvbnMsIHBvc2l4ID0gdXRpbHMuaXNXaW5kb3dzKG9wdGlvbnMpKSA9PiB7XG4gIGNvbnN0IHJlZ2V4ID0gZ2xvYiBpbnN0YW5jZW9mIFJlZ0V4cCA/IGdsb2IgOiBwaWNvbWF0Y2gubWFrZVJlKGdsb2IsIG9wdGlvbnMpO1xuICByZXR1cm4gcmVnZXgudGVzdChwYXRoLmJhc2VuYW1lKGlucHV0KSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiAqKmFueSoqIG9mIHRoZSBnaXZlbiBnbG9iIGBwYXR0ZXJuc2AgbWF0Y2ggdGhlIHNwZWNpZmllZCBgc3RyaW5nYC5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcGljb21hdGNoID0gcmVxdWlyZSgncGljb21hdGNoJyk7XG4gKiAvLyBwaWNvbWF0Y2guaXNNYXRjaChzdHJpbmcsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBpY29tYXRjaC5pc01hdGNoKCdhLmEnLCBbJ2IuKicsICcqLmEnXSkpOyAvLz0+IHRydWVcbiAqIGNvbnNvbGUubG9nKHBpY29tYXRjaC5pc01hdGNoKCdhLmEnLCAnYi4qJykpOyAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBzdHIgVGhlIHN0cmluZyB0byB0ZXN0LlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBhdHRlcm5zIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpLlxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFueSBwYXR0ZXJucyBtYXRjaCBgc3RyYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5waWNvbWF0Y2guaXNNYXRjaCA9IChzdHIsIHBhdHRlcm5zLCBvcHRpb25zKSA9PiBwaWNvbWF0Y2gocGF0dGVybnMsIG9wdGlvbnMpKHN0cik7XG5cbi8qKlxuICogUGFyc2UgYSBnbG9iIHBhdHRlcm4gdG8gY3JlYXRlIHRoZSBzb3VyY2Ugc3RyaW5nIGZvciBhIHJlZ3VsYXJcbiAqIGV4cHJlc3Npb24uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuICogY29uc3QgcmVzdWx0ID0gcGljb21hdGNoLnBhcnNlKHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB1c2VmdWwgcHJvcGVydGllcyBhbmQgb3V0cHV0IHRvIGJlIHVzZWQgYXMgYSByZWdleCBzb3VyY2Ugc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5waWNvbWF0Y2gucGFyc2UgPSAocGF0dGVybiwgb3B0aW9ucykgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkgcmV0dXJuIHBhdHRlcm4ubWFwKHAgPT4gcGljb21hdGNoLnBhcnNlKHAsIG9wdGlvbnMpKTtcbiAgcmV0dXJuIHBhcnNlKHBhdHRlcm4sIHsgLi4ub3B0aW9ucywgZmFzdHBhdGhzOiBmYWxzZSB9KTtcbn07XG5cbi8qKlxuICogU2NhbiBhIGdsb2IgcGF0dGVybiB0byBzZXBhcmF0ZSB0aGUgcGF0dGVybiBpbnRvIHNlZ21lbnRzLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwaWNvbWF0Y2ggPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcbiAqIC8vIHBpY29tYXRjaC5zY2FuKGlucHV0Wywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IHBpY29tYXRjaC5zY2FuKCchLi9mb28vKi5qcycpO1xuICogY29uc29sZS5sb2cocmVzdWx0KTtcbiAqIHsgcHJlZml4OiAnIS4vJyxcbiAqICAgaW5wdXQ6ICchLi9mb28vKi5qcycsXG4gKiAgIHN0YXJ0OiAzLFxuICogICBiYXNlOiAnZm9vJyxcbiAqICAgZ2xvYjogJyouanMnLFxuICogICBpc0JyYWNlOiBmYWxzZSxcbiAqICAgaXNCcmFja2V0OiBmYWxzZSxcbiAqICAgaXNHbG9iOiB0cnVlLFxuICogICBpc0V4dGdsb2I6IGZhbHNlLFxuICogICBpc0dsb2JzdGFyOiBmYWxzZSxcbiAqICAgbmVnYXRlZDogdHJ1ZSB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgaW5wdXRgIEdsb2IgcGF0dGVybiB0byBzY2FuLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBpY29tYXRjaC5zY2FuID0gKGlucHV0LCBvcHRpb25zKSA9PiBzY2FuKGlucHV0LCBvcHRpb25zKTtcblxuLyoqXG4gKiBDb21waWxlIGEgcmVndWxhciBleHByZXNzaW9uIGZyb20gdGhlIGBzdGF0ZWAgb2JqZWN0IHJldHVybmVkIGJ5IHRoZVxuICogW3BhcnNlKCldKCNwYXJzZSkgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBgc3RhdGVgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGByZXR1cm5PdXRwdXRgIEludGVuZGVkIGZvciBpbXBsZW1lbnRvcnMsIHRoaXMgYXJndW1lbnQgYWxsb3dzIHlvdSB0byByZXR1cm4gdGhlIHJhdyBvdXRwdXQgZnJvbSB0aGUgcGFyc2VyLlxuICogQHBhcmFtIHtCb29sZWFufSBgcmV0dXJuU3RhdGVgIEFkZHMgdGhlIHN0YXRlIHRvIGEgYHN0YXRlYCBwcm9wZXJ0eSBvbiB0aGUgcmV0dXJuZWQgcmVnZXguIFVzZWZ1bCBmb3IgaW1wbGVtZW50b3JzIGFuZCBkZWJ1Z2dpbmcuXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBpY29tYXRjaC5jb21waWxlUmUgPSAoc3RhdGUsIG9wdGlvbnMsIHJldHVybk91dHB1dCA9IGZhbHNlLCByZXR1cm5TdGF0ZSA9IGZhbHNlKSA9PiB7XG4gIGlmIChyZXR1cm5PdXRwdXQgPT09IHRydWUpIHtcbiAgICByZXR1cm4gc3RhdGUub3V0cHV0O1xuICB9XG5cbiAgY29uc3Qgb3B0cyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHByZXBlbmQgPSBvcHRzLmNvbnRhaW5zID8gJycgOiAnXic7XG4gIGNvbnN0IGFwcGVuZCA9IG9wdHMuY29udGFpbnMgPyAnJyA6ICckJztcblxuICBsZXQgc291cmNlID0gYCR7cHJlcGVuZH0oPzoke3N0YXRlLm91dHB1dH0pJHthcHBlbmR9YDtcbiAgaWYgKHN0YXRlICYmIHN0YXRlLm5lZ2F0ZWQgPT09IHRydWUpIHtcbiAgICBzb3VyY2UgPSBgXig/ISR7c291cmNlfSkuKiRgO1xuICB9XG5cbiAgY29uc3QgcmVnZXggPSBwaWNvbWF0Y2gudG9SZWdleChzb3VyY2UsIG9wdGlvbnMpO1xuICBpZiAocmV0dXJuU3RhdGUgPT09IHRydWUpIHtcbiAgICByZWdleC5zdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAgcmV0dXJuIHJlZ2V4O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSBhIHBhcnNlZCBnbG9iIHBhdHRlcm4uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuICogY29uc3Qgc3RhdGUgPSBwaWNvbWF0Y2gucGFyc2UoJyouanMnKTtcbiAqIC8vIHBpY29tYXRjaC5jb21waWxlUmUoc3RhdGVbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cocGljb21hdGNoLmNvbXBpbGVSZShzdGF0ZSkpO1xuICogLy89PiAvXig/Oig/IVxcLikoPz0uKVteL10qP1xcLmpzKSQvXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RhdGVgIFRoZSBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGUgYC5wYXJzZWAgbWV0aG9kLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHBhcmFtIHtCb29sZWFufSBgcmV0dXJuT3V0cHV0YCBJbXBsZW1lbnRvcnMgbWF5IHVzZSB0aGlzIGFyZ3VtZW50IHRvIHJldHVybiB0aGUgY29tcGlsZWQgb3V0cHV0LCBpbnN0ZWFkIG9mIGEgcmVndWxhciBleHByZXNzaW9uLiBUaGlzIGlzIG5vdCBleHBvc2VkIG9uIHRoZSBvcHRpb25zIHRvIHByZXZlbnQgZW5kLXVzZXJzIGZyb20gbXV0YXRpbmcgdGhlIHJlc3VsdC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYHJldHVyblN0YXRlYCBJbXBsZW1lbnRvcnMgbWF5IHVzZSB0aGlzIGFyZ3VtZW50IHRvIHJldHVybiB0aGUgc3RhdGUgZnJvbSB0aGUgcGFyc2VkIGdsb2Igd2l0aCB0aGUgcmV0dXJuZWQgcmVndWxhciBleHByZXNzaW9uLlxuICogQHJldHVybiB7UmVnRXhwfSBSZXR1cm5zIGEgcmVnZXggY3JlYXRlZCBmcm9tIHRoZSBnaXZlbiBwYXR0ZXJuLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5waWNvbWF0Y2gubWFrZVJlID0gKGlucHV0LCBvcHRpb25zID0ge30sIHJldHVybk91dHB1dCA9IGZhbHNlLCByZXR1cm5TdGF0ZSA9IGZhbHNlKSA9PiB7XG4gIGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICB9XG5cbiAgbGV0IHBhcnNlZCA9IHsgbmVnYXRlZDogZmFsc2UsIGZhc3RwYXRoczogdHJ1ZSB9O1xuXG4gIGlmIChvcHRpb25zLmZhc3RwYXRocyAhPT0gZmFsc2UgJiYgKGlucHV0WzBdID09PSAnLicgfHwgaW5wdXRbMF0gPT09ICcqJykpIHtcbiAgICBwYXJzZWQub3V0cHV0ID0gcGFyc2UuZmFzdHBhdGhzKGlucHV0LCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICghcGFyc2VkLm91dHB1dCkge1xuICAgIHBhcnNlZCA9IHBhcnNlKGlucHV0LCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBwaWNvbWF0Y2guY29tcGlsZVJlKHBhcnNlZCwgb3B0aW9ucywgcmV0dXJuT3V0cHV0LCByZXR1cm5TdGF0ZSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmcm9tIHRoZSBnaXZlbiByZWdleCBzb3VyY2Ugc3RyaW5nLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwaWNvbWF0Y2ggPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcbiAqIC8vIHBpY29tYXRjaC50b1JlZ2V4KHNvdXJjZVssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zdCB7IG91dHB1dCB9ID0gcGljb21hdGNoLnBhcnNlKCcqLmpzJyk7XG4gKiBjb25zb2xlLmxvZyhwaWNvbWF0Y2gudG9SZWdleChvdXRwdXQpKTtcbiAqIC8vPT4gL14oPzooPyFcXC4pKD89LilbXi9dKj9cXC5qcykkL1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHNvdXJjZWAgUmVndWxhciBleHByZXNzaW9uIHNvdXJjZSBzdHJpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBpY29tYXRjaC50b1JlZ2V4ID0gKHNvdXJjZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHNvdXJjZSwgb3B0cy5mbGFncyB8fCAob3B0cy5ub2Nhc2UgPyAnaScgOiAnJykpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnID09PSB0cnVlKSB0aHJvdyBlcnI7XG4gICAgcmV0dXJuIC8kXi87XG4gIH1cbn07XG5cbi8qKlxuICogUGljb21hdGNoIGNvbnN0YW50cy5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5waWNvbWF0Y2guY29uc3RhbnRzID0gY29uc3RhbnRzO1xuXG4vKipcbiAqIEV4cG9zZSBcInBpY29tYXRjaFwiXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBwaWNvbWF0Y2g7XG4iXSwibmFtZXMiOlsicGF0aCIsInJlcXVpcmUiLCJzY2FuIiwicGFyc2UiLCJ1dGlscyIsImNvbnN0YW50cyIsImlzT2JqZWN0IiwidmFsIiwiQXJyYXkiLCJpc0FycmF5IiwicGljb21hdGNoIiwiZ2xvYiIsIm9wdGlvbnMiLCJyZXR1cm5TdGF0ZSIsImZucyIsIm1hcCIsImlucHV0IiwiYXJyYXlNYXRjaGVyIiwic3RyIiwiaXNNYXRjaCIsInN0YXRlIiwiaXNTdGF0ZSIsInRva2VucyIsIlR5cGVFcnJvciIsIm9wdHMiLCJwb3NpeCIsImlzV2luZG93cyIsInJlZ2V4IiwiY29tcGlsZVJlIiwibWFrZVJlIiwiaXNJZ25vcmVkIiwiaWdub3JlIiwiaWdub3JlT3B0cyIsIm9uTWF0Y2giLCJvblJlc3VsdCIsIm1hdGNoZXIiLCJyZXR1cm5PYmplY3QiLCJtYXRjaCIsIm91dHB1dCIsInRlc3QiLCJyZXN1bHQiLCJvbklnbm9yZSIsImZvcm1hdCIsInRvUG9zaXhTbGFzaGVzIiwiY2FwdHVyZSIsIm1hdGNoQmFzZSIsImJhc2VuYW1lIiwiZXhlYyIsIkJvb2xlYW4iLCJSZWdFeHAiLCJwYXR0ZXJucyIsInBhdHRlcm4iLCJwIiwiZmFzdHBhdGhzIiwicmV0dXJuT3V0cHV0IiwicHJlcGVuZCIsImNvbnRhaW5zIiwiYXBwZW5kIiwic291cmNlIiwibmVnYXRlZCIsInRvUmVnZXgiLCJwYXJzZWQiLCJmbGFncyIsIm5vY2FzZSIsImVyciIsImRlYnVnIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js\");\nconst { CHAR_ASTERISK, /* * */ CHAR_AT, /* @ */ CHAR_BACKWARD_SLASH, /* \\ */ CHAR_COMMA, /* , */ CHAR_DOT, /* . */ CHAR_EXCLAMATION_MARK, /* ! */ CHAR_FORWARD_SLASH, /* / */ CHAR_LEFT_CURLY_BRACE, /* { */ CHAR_LEFT_PARENTHESES, /* ( */ CHAR_LEFT_SQUARE_BRACKET, /* [ */ CHAR_PLUS, /* + */ CHAR_QUESTION_MARK, /* ? */ CHAR_RIGHT_CURLY_BRACE, /* } */ CHAR_RIGHT_PARENTHESES, /* ) */ CHAR_RIGHT_SQUARE_BRACKET/* ] */  } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js\");\nconst isPathSeparator = (code)=>{\n    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\nconst depth = (token)=>{\n    if (token.isPrefix !== true) {\n        token.depth = token.isGlobstar ? Infinity : 1;\n    }\n};\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\n * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */ const scan = (input, options)=>{\n    const opts = options || {};\n    const length = input.length - 1;\n    const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n    const slashes = [];\n    const tokens = [];\n    const parts = [];\n    let str = input;\n    let index = -1;\n    let start = 0;\n    let lastIndex = 0;\n    let isBrace = false;\n    let isBracket = false;\n    let isGlob = false;\n    let isExtglob = false;\n    let isGlobstar = false;\n    let braceEscaped = false;\n    let backslashes = false;\n    let negated = false;\n    let negatedExtglob = false;\n    let finished = false;\n    let braces = 0;\n    let prev;\n    let code;\n    let token = {\n        value: \"\",\n        depth: 0,\n        isGlob: false\n    };\n    const eos = ()=>index >= length;\n    const peek = ()=>str.charCodeAt(index + 1);\n    const advance = ()=>{\n        prev = code;\n        return str.charCodeAt(++index);\n    };\n    while(index < length){\n        code = advance();\n        let next;\n        if (code === CHAR_BACKWARD_SLASH) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            if (code === CHAR_LEFT_CURLY_BRACE) {\n                braceEscaped = true;\n            }\n            continue;\n        }\n        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n            braces++;\n            while(eos() !== true && (code = advance())){\n                if (code === CHAR_BACKWARD_SLASH) {\n                    backslashes = token.backslashes = true;\n                    advance();\n                    continue;\n                }\n                if (code === CHAR_LEFT_CURLY_BRACE) {\n                    braces++;\n                    continue;\n                }\n                if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n                    isBrace = token.isBrace = true;\n                    isGlob = token.isGlob = true;\n                    finished = true;\n                    if (scanToEnd === true) {\n                        continue;\n                    }\n                    break;\n                }\n                if (braceEscaped !== true && code === CHAR_COMMA) {\n                    isBrace = token.isBrace = true;\n                    isGlob = token.isGlob = true;\n                    finished = true;\n                    if (scanToEnd === true) {\n                        continue;\n                    }\n                    break;\n                }\n                if (code === CHAR_RIGHT_CURLY_BRACE) {\n                    braces--;\n                    if (braces === 0) {\n                        braceEscaped = false;\n                        isBrace = token.isBrace = true;\n                        finished = true;\n                        break;\n                    }\n                }\n            }\n            if (scanToEnd === true) {\n                continue;\n            }\n            break;\n        }\n        if (code === CHAR_FORWARD_SLASH) {\n            slashes.push(index);\n            tokens.push(token);\n            token = {\n                value: \"\",\n                depth: 0,\n                isGlob: false\n            };\n            if (finished === true) continue;\n            if (prev === CHAR_DOT && index === start + 1) {\n                start += 2;\n                continue;\n            }\n            lastIndex = index + 1;\n            continue;\n        }\n        if (opts.noext !== true) {\n            const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;\n            if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n                isGlob = token.isGlob = true;\n                isExtglob = token.isExtglob = true;\n                finished = true;\n                if (code === CHAR_EXCLAMATION_MARK && index === start) {\n                    negatedExtglob = true;\n                }\n                if (scanToEnd === true) {\n                    while(eos() !== true && (code = advance())){\n                        if (code === CHAR_BACKWARD_SLASH) {\n                            backslashes = token.backslashes = true;\n                            code = advance();\n                            continue;\n                        }\n                        if (code === CHAR_RIGHT_PARENTHESES) {\n                            isGlob = token.isGlob = true;\n                            finished = true;\n                            break;\n                        }\n                    }\n                    continue;\n                }\n                break;\n            }\n        }\n        if (code === CHAR_ASTERISK) {\n            if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n            isGlob = token.isGlob = true;\n            finished = true;\n            if (scanToEnd === true) {\n                continue;\n            }\n            break;\n        }\n        if (code === CHAR_QUESTION_MARK) {\n            isGlob = token.isGlob = true;\n            finished = true;\n            if (scanToEnd === true) {\n                continue;\n            }\n            break;\n        }\n        if (code === CHAR_LEFT_SQUARE_BRACKET) {\n            while(eos() !== true && (next = advance())){\n                if (next === CHAR_BACKWARD_SLASH) {\n                    backslashes = token.backslashes = true;\n                    advance();\n                    continue;\n                }\n                if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n                    isBracket = token.isBracket = true;\n                    isGlob = token.isGlob = true;\n                    finished = true;\n                    break;\n                }\n            }\n            if (scanToEnd === true) {\n                continue;\n            }\n            break;\n        }\n        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n            negated = token.negated = true;\n            start++;\n            continue;\n        }\n        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n            isGlob = token.isGlob = true;\n            if (scanToEnd === true) {\n                while(eos() !== true && (code = advance())){\n                    if (code === CHAR_LEFT_PARENTHESES) {\n                        backslashes = token.backslashes = true;\n                        code = advance();\n                        continue;\n                    }\n                    if (code === CHAR_RIGHT_PARENTHESES) {\n                        finished = true;\n                        break;\n                    }\n                }\n                continue;\n            }\n            break;\n        }\n        if (isGlob === true) {\n            finished = true;\n            if (scanToEnd === true) {\n                continue;\n            }\n            break;\n        }\n    }\n    if (opts.noext === true) {\n        isExtglob = false;\n        isGlob = false;\n    }\n    let base = str;\n    let prefix = \"\";\n    let glob = \"\";\n    if (start > 0) {\n        prefix = str.slice(0, start);\n        str = str.slice(start);\n        lastIndex -= start;\n    }\n    if (base && isGlob === true && lastIndex > 0) {\n        base = str.slice(0, lastIndex);\n        glob = str.slice(lastIndex);\n    } else if (isGlob === true) {\n        base = \"\";\n        glob = str;\n    } else {\n        base = str;\n    }\n    if (base && base !== \"\" && base !== \"/\" && base !== str) {\n        if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n            base = base.slice(0, -1);\n        }\n    }\n    if (opts.unescape === true) {\n        if (glob) glob = utils.removeBackslashes(glob);\n        if (base && backslashes === true) {\n            base = utils.removeBackslashes(base);\n        }\n    }\n    const state = {\n        prefix,\n        input,\n        start,\n        base,\n        glob,\n        isBrace,\n        isBracket,\n        isGlob,\n        isExtglob,\n        isGlobstar,\n        negated,\n        negatedExtglob\n    };\n    if (opts.tokens === true) {\n        state.maxDepth = 0;\n        if (!isPathSeparator(code)) {\n            tokens.push(token);\n        }\n        state.tokens = tokens;\n    }\n    if (opts.parts === true || opts.tokens === true) {\n        let prevIndex;\n        for(let idx = 0; idx < slashes.length; idx++){\n            const n = prevIndex ? prevIndex + 1 : start;\n            const i = slashes[idx];\n            const value = input.slice(n, i);\n            if (opts.tokens) {\n                if (idx === 0 && start !== 0) {\n                    tokens[idx].isPrefix = true;\n                    tokens[idx].value = prefix;\n                } else {\n                    tokens[idx].value = value;\n                }\n                depth(tokens[idx]);\n                state.maxDepth += tokens[idx].depth;\n            }\n            if (idx !== 0 || value !== \"\") {\n                parts.push(value);\n            }\n            prevIndex = i;\n        }\n        if (prevIndex && prevIndex + 1 < input.length) {\n            const value = input.slice(prevIndex + 1);\n            parts.push(value);\n            if (opts.tokens) {\n                tokens[tokens.length - 1].value = value;\n                depth(tokens[tokens.length - 1]);\n                state.maxDepth += tokens[tokens.length - 1].depth;\n            }\n        }\n        state.slashes = slashes;\n        state.parts = parts;\n    }\n    return state;\n};\nmodule.exports = scan;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vcGljb21hdGNoQDIuMy4xL25vZGVfbW9kdWxlcy9waWNvbWF0Y2gvbGliL3NjYW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUN0QixNQUFNLEVBQ0pDLGFBQWEsRUFBYyxLQUFLLEdBQ2hDQyxPQUFPLEVBQW9CLEtBQUssR0FDaENDLG1CQUFtQixFQUFRLEtBQUssR0FDaENDLFVBQVUsRUFBaUIsS0FBSyxHQUNoQ0MsUUFBUSxFQUFtQixLQUFLLEdBQ2hDQyxxQkFBcUIsRUFBTSxLQUFLLEdBQ2hDQyxrQkFBa0IsRUFBUyxLQUFLLEdBQ2hDQyxxQkFBcUIsRUFBTSxLQUFLLEdBQ2hDQyxxQkFBcUIsRUFBTSxLQUFLLEdBQ2hDQyx3QkFBd0IsRUFBRyxLQUFLLEdBQ2hDQyxTQUFTLEVBQWtCLEtBQUssR0FDaENDLGtCQUFrQixFQUFTLEtBQUssR0FDaENDLHNCQUFzQixFQUFLLEtBQUssR0FDaENDLHNCQUFzQixFQUFLLEtBQUssR0FDaENDLHlCQUF5QixLQUFPLEtBQ2pDLEdBQUdmLG1CQUFPQSxDQUFDO0FBRVosTUFBTWdCLGtCQUFrQkMsQ0FBQUE7SUFDdEIsT0FBT0EsU0FBU1Ysc0JBQXNCVSxTQUFTZDtBQUNqRDtBQUVBLE1BQU1lLFFBQVFDLENBQUFBO0lBQ1osSUFBSUEsTUFBTUMsUUFBUSxLQUFLLE1BQU07UUFDM0JELE1BQU1ELEtBQUssR0FBR0MsTUFBTUUsVUFBVSxHQUFHQyxXQUFXO0lBQzlDO0FBQ0Y7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FFRCxNQUFNQyxPQUFPLENBQUNDLE9BQU9DO0lBQ25CLE1BQU1DLE9BQU9ELFdBQVcsQ0FBQztJQUV6QixNQUFNRSxTQUFTSCxNQUFNRyxNQUFNLEdBQUc7SUFDOUIsTUFBTUMsWUFBWUYsS0FBS0csS0FBSyxLQUFLLFFBQVFILEtBQUtFLFNBQVMsS0FBSztJQUM1RCxNQUFNRSxVQUFVLEVBQUU7SUFD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TyxHQUFHaEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90YWlsd2luZHVpLXN0dWRpby8uL25vZGVfbW9kdWxlcy8ucG5wbS9waWNvbWF0Y2hAMi4zLjEvbm9kZV9tb2R1bGVzL3BpY29tYXRjaC9saWIvc2Nhbi5qcz8zYWMyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCB7XG4gIENIQVJfQVNURVJJU0ssICAgICAgICAgICAgIC8qICogKi9cbiAgQ0hBUl9BVCwgICAgICAgICAgICAgICAgICAgLyogQCAqL1xuICBDSEFSX0JBQ0tXQVJEX1NMQVNILCAgICAgICAvKiBcXCAqL1xuICBDSEFSX0NPTU1BLCAgICAgICAgICAgICAgICAvKiAsICovXG4gIENIQVJfRE9ULCAgICAgICAgICAgICAgICAgIC8qIC4gKi9cbiAgQ0hBUl9FWENMQU1BVElPTl9NQVJLLCAgICAgLyogISAqL1xuICBDSEFSX0ZPUldBUkRfU0xBU0gsICAgICAgICAvKiAvICovXG4gIENIQVJfTEVGVF9DVVJMWV9CUkFDRSwgICAgIC8qIHsgKi9cbiAgQ0hBUl9MRUZUX1BBUkVOVEhFU0VTLCAgICAgLyogKCAqL1xuICBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQsICAvKiBbICovXG4gIENIQVJfUExVUywgICAgICAgICAgICAgICAgIC8qICsgKi9cbiAgQ0hBUl9RVUVTVElPTl9NQVJLLCAgICAgICAgLyogPyAqL1xuICBDSEFSX1JJR0hUX0NVUkxZX0JSQUNFLCAgICAvKiB9ICovXG4gIENIQVJfUklHSFRfUEFSRU5USEVTRVMsICAgIC8qICkgKi9cbiAgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCAgLyogXSAqL1xufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IGlzUGF0aFNlcGFyYXRvciA9IGNvZGUgPT4ge1xuICByZXR1cm4gY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIIHx8IGNvZGUgPT09IENIQVJfQkFDS1dBUkRfU0xBU0g7XG59O1xuXG5jb25zdCBkZXB0aCA9IHRva2VuID0+IHtcbiAgaWYgKHRva2VuLmlzUHJlZml4ICE9PSB0cnVlKSB7XG4gICAgdG9rZW4uZGVwdGggPSB0b2tlbi5pc0dsb2JzdGFyID8gSW5maW5pdHkgOiAxO1xuICB9XG59O1xuXG4vKipcbiAqIFF1aWNrbHkgc2NhbnMgYSBnbG9iIHBhdHRlcm4gYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggYSBoYW5kZnVsIG9mXG4gKiB1c2VmdWwgcHJvcGVydGllcywgbGlrZSBgaXNHbG9iYCwgYHBhdGhgICh0aGUgbGVhZGluZyBub24tZ2xvYiwgaWYgaXQgZXhpc3RzKSxcbiAqIGBnbG9iYCAodGhlIGFjdHVhbCBwYXR0ZXJuKSwgYG5lZ2F0ZWRgICh0cnVlIGlmIHRoZSBwYXRoIHN0YXJ0cyB3aXRoIGAhYCBidXQgbm90XG4gKiB3aXRoIGAhKGApIGFuZCBgbmVnYXRlZEV4dGdsb2JgICh0cnVlIGlmIHRoZSBwYXRoIHN0YXJ0cyB3aXRoIGAhKGApLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwbSA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuICogY29uc29sZS5sb2cocG0uc2NhbignZm9vL2Jhci8qLmpzJykpO1xuICogeyBpc0dsb2I6IHRydWUsIGlucHV0OiAnZm9vL2Jhci8qLmpzJywgYmFzZTogJ2Zvby9iYXInLCBnbG9iOiAnKi5qcycgfVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0b2tlbnMgYW5kIHJlZ2V4IHNvdXJjZSBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmNvbnN0IHNjYW4gPSAoaW5wdXQsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgb3B0cyA9IG9wdGlvbnMgfHwge307XG5cbiAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoIC0gMTtcbiAgY29uc3Qgc2NhblRvRW5kID0gb3B0cy5wYXJ0cyA9PT0gdHJ1ZSB8fCBvcHRzLnNjYW5Ub0VuZCA9PT0gdHJ1ZTtcbiAgY29uc3Qgc2xhc2hlcyA9IFtdO1xuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgY29uc3QgcGFydHMgPSBbXTtcblxuICBsZXQgc3RyID0gaW5wdXQ7XG4gIGxldCBpbmRleCA9IC0xO1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgbGV0IGlzQnJhY2UgPSBmYWxzZTtcbiAgbGV0IGlzQnJhY2tldCA9IGZhbHNlO1xuICBsZXQgaXNHbG9iID0gZmFsc2U7XG4gIGxldCBpc0V4dGdsb2IgPSBmYWxzZTtcbiAgbGV0IGlzR2xvYnN0YXIgPSBmYWxzZTtcbiAgbGV0IGJyYWNlRXNjYXBlZCA9IGZhbHNlO1xuICBsZXQgYmFja3NsYXNoZXMgPSBmYWxzZTtcbiAgbGV0IG5lZ2F0ZWQgPSBmYWxzZTtcbiAgbGV0IG5lZ2F0ZWRFeHRnbG9iID0gZmFsc2U7XG4gIGxldCBmaW5pc2hlZCA9IGZhbHNlO1xuICBsZXQgYnJhY2VzID0gMDtcbiAgbGV0IHByZXY7XG4gIGxldCBjb2RlO1xuICBsZXQgdG9rZW4gPSB7IHZhbHVlOiAnJywgZGVwdGg6IDAsIGlzR2xvYjogZmFsc2UgfTtcblxuICBjb25zdCBlb3MgPSAoKSA9PiBpbmRleCA+PSBsZW5ndGg7XG4gIGNvbnN0IHBlZWsgPSAoKSA9PiBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICBjb25zdCBhZHZhbmNlID0gKCkgPT4ge1xuICAgIHByZXYgPSBjb2RlO1xuICAgIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4KTtcbiAgfTtcblxuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICBjb2RlID0gYWR2YW5jZSgpO1xuICAgIGxldCBuZXh0O1xuXG4gICAgaWYgKGNvZGUgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcbiAgICAgIGJhY2tzbGFzaGVzID0gdG9rZW4uYmFja3NsYXNoZXMgPSB0cnVlO1xuICAgICAgY29kZSA9IGFkdmFuY2UoKTtcblxuICAgICAgaWYgKGNvZGUgPT09IENIQVJfTEVGVF9DVVJMWV9CUkFDRSkge1xuICAgICAgICBicmFjZUVzY2FwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGJyYWNlRXNjYXBlZCA9PT0gdHJ1ZSB8fCBjb2RlID09PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0UpIHtcbiAgICAgIGJyYWNlcysrO1xuXG4gICAgICB3aGlsZSAoZW9zKCkgIT09IHRydWUgJiYgKGNvZGUgPSBhZHZhbmNlKCkpKSB7XG4gICAgICAgIGlmIChjb2RlID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgYmFja3NsYXNoZXMgPSB0b2tlbi5iYWNrc2xhc2hlcyA9IHRydWU7XG4gICAgICAgICAgYWR2YW5jZSgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfTEVGVF9DVVJMWV9CUkFDRSkge1xuICAgICAgICAgIGJyYWNlcysrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJyYWNlRXNjYXBlZCAhPT0gdHJ1ZSAmJiBjb2RlID09PSBDSEFSX0RPVCAmJiAoY29kZSA9IGFkdmFuY2UoKSkgPT09IENIQVJfRE9UKSB7XG4gICAgICAgICAgaXNCcmFjZSA9IHRva2VuLmlzQnJhY2UgPSB0cnVlO1xuICAgICAgICAgIGlzR2xvYiA9IHRva2VuLmlzR2xvYiA9IHRydWU7XG4gICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnJhY2VFc2NhcGVkICE9PSB0cnVlICYmIGNvZGUgPT09IENIQVJfQ09NTUEpIHtcbiAgICAgICAgICBpc0JyYWNlID0gdG9rZW4uaXNCcmFjZSA9IHRydWU7XG4gICAgICAgICAgaXNHbG9iID0gdG9rZW4uaXNHbG9iID0gdHJ1ZTtcbiAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSBDSEFSX1JJR0hUX0NVUkxZX0JSQUNFKSB7XG4gICAgICAgICAgYnJhY2VzLS07XG5cbiAgICAgICAgICBpZiAoYnJhY2VzID09PSAwKSB7XG4gICAgICAgICAgICBicmFjZUVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlzQnJhY2UgPSB0b2tlbi5pc0JyYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XG4gICAgICBzbGFzaGVzLnB1c2goaW5kZXgpO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgdG9rZW4gPSB7IHZhbHVlOiAnJywgZGVwdGg6IDAsIGlzR2xvYjogZmFsc2UgfTtcblxuICAgICAgaWYgKGZpbmlzaGVkID09PSB0cnVlKSBjb250aW51ZTtcbiAgICAgIGlmIChwcmV2ID09PSBDSEFSX0RPVCAmJiBpbmRleCA9PT0gKHN0YXJ0ICsgMSkpIHtcbiAgICAgICAgc3RhcnQgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChvcHRzLm5vZXh0ICE9PSB0cnVlKSB7XG4gICAgICBjb25zdCBpc0V4dGdsb2JDaGFyID0gY29kZSA9PT0gQ0hBUl9QTFVTXG4gICAgICAgIHx8IGNvZGUgPT09IENIQVJfQVRcbiAgICAgICAgfHwgY29kZSA9PT0gQ0hBUl9BU1RFUklTS1xuICAgICAgICB8fCBjb2RlID09PSBDSEFSX1FVRVNUSU9OX01BUktcbiAgICAgICAgfHwgY29kZSA9PT0gQ0hBUl9FWENMQU1BVElPTl9NQVJLO1xuXG4gICAgICBpZiAoaXNFeHRnbG9iQ2hhciA9PT0gdHJ1ZSAmJiBwZWVrKCkgPT09IENIQVJfTEVGVF9QQVJFTlRIRVNFUykge1xuICAgICAgICBpc0dsb2IgPSB0b2tlbi5pc0dsb2IgPSB0cnVlO1xuICAgICAgICBpc0V4dGdsb2IgPSB0b2tlbi5pc0V4dGdsb2IgPSB0cnVlO1xuICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGlmIChjb2RlID09PSBDSEFSX0VYQ0xBTUFUSU9OX01BUksgJiYgaW5kZXggPT09IHN0YXJ0KSB7XG4gICAgICAgICAgbmVnYXRlZEV4dGdsb2IgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHdoaWxlIChlb3MoKSAhPT0gdHJ1ZSAmJiAoY29kZSA9IGFkdmFuY2UoKSkpIHtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAgIGJhY2tzbGFzaGVzID0gdG9rZW4uYmFja3NsYXNoZXMgPSB0cnVlO1xuICAgICAgICAgICAgICBjb2RlID0gYWR2YW5jZSgpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfUklHSFRfUEFSRU5USEVTRVMpIHtcbiAgICAgICAgICAgICAgaXNHbG9iID0gdG9rZW4uaXNHbG9iID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IENIQVJfQVNURVJJU0spIHtcbiAgICAgIGlmIChwcmV2ID09PSBDSEFSX0FTVEVSSVNLKSBpc0dsb2JzdGFyID0gdG9rZW4uaXNHbG9ic3RhciA9IHRydWU7XG4gICAgICBpc0dsb2IgPSB0b2tlbi5pc0dsb2IgPSB0cnVlO1xuICAgICAgZmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IENIQVJfUVVFU1RJT05fTUFSSykge1xuICAgICAgaXNHbG9iID0gdG9rZW4uaXNHbG9iID0gdHJ1ZTtcbiAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQpIHtcbiAgICAgIHdoaWxlIChlb3MoKSAhPT0gdHJ1ZSAmJiAobmV4dCA9IGFkdmFuY2UoKSkpIHtcbiAgICAgICAgaWYgKG5leHQgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcbiAgICAgICAgICBiYWNrc2xhc2hlcyA9IHRva2VuLmJhY2tzbGFzaGVzID0gdHJ1ZTtcbiAgICAgICAgICBhZHZhbmNlKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dCA9PT0gQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCkge1xuICAgICAgICAgIGlzQnJhY2tldCA9IHRva2VuLmlzQnJhY2tldCA9IHRydWU7XG4gICAgICAgICAgaXNHbG9iID0gdG9rZW4uaXNHbG9iID0gdHJ1ZTtcbiAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMubm9uZWdhdGUgIT09IHRydWUgJiYgY29kZSA9PT0gQ0hBUl9FWENMQU1BVElPTl9NQVJLICYmIGluZGV4ID09PSBzdGFydCkge1xuICAgICAgbmVnYXRlZCA9IHRva2VuLm5lZ2F0ZWQgPSB0cnVlO1xuICAgICAgc3RhcnQrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChvcHRzLm5vcGFyZW4gIT09IHRydWUgJiYgY29kZSA9PT0gQ0hBUl9MRUZUX1BBUkVOVEhFU0VTKSB7XG4gICAgICBpc0dsb2IgPSB0b2tlbi5pc0dsb2IgPSB0cnVlO1xuXG4gICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG4gICAgICAgIHdoaWxlIChlb3MoKSAhPT0gdHJ1ZSAmJiAoY29kZSA9IGFkdmFuY2UoKSkpIHtcbiAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9MRUZUX1BBUkVOVEhFU0VTKSB7XG4gICAgICAgICAgICBiYWNrc2xhc2hlcyA9IHRva2VuLmJhY2tzbGFzaGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvZGUgPSBhZHZhbmNlKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUykge1xuICAgICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGlzR2xvYiA9PT0gdHJ1ZSkge1xuICAgICAgZmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5ub2V4dCA9PT0gdHJ1ZSkge1xuICAgIGlzRXh0Z2xvYiA9IGZhbHNlO1xuICAgIGlzR2xvYiA9IGZhbHNlO1xuICB9XG5cbiAgbGV0IGJhc2UgPSBzdHI7XG4gIGxldCBwcmVmaXggPSAnJztcbiAgbGV0IGdsb2IgPSAnJztcblxuICBpZiAoc3RhcnQgPiAwKSB7XG4gICAgcHJlZml4ID0gc3RyLnNsaWNlKDAsIHN0YXJ0KTtcbiAgICBzdHIgPSBzdHIuc2xpY2Uoc3RhcnQpO1xuICAgIGxhc3RJbmRleCAtPSBzdGFydDtcbiAgfVxuXG4gIGlmIChiYXNlICYmIGlzR2xvYiA9PT0gdHJ1ZSAmJiBsYXN0SW5kZXggPiAwKSB7XG4gICAgYmFzZSA9IHN0ci5zbGljZSgwLCBsYXN0SW5kZXgpO1xuICAgIGdsb2IgPSBzdHIuc2xpY2UobGFzdEluZGV4KTtcbiAgfSBlbHNlIGlmIChpc0dsb2IgPT09IHRydWUpIHtcbiAgICBiYXNlID0gJyc7XG4gICAgZ2xvYiA9IHN0cjtcbiAgfSBlbHNlIHtcbiAgICBiYXNlID0gc3RyO1xuICB9XG5cbiAgaWYgKGJhc2UgJiYgYmFzZSAhPT0gJycgJiYgYmFzZSAhPT0gJy8nICYmIGJhc2UgIT09IHN0cikge1xuICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoYmFzZS5jaGFyQ29kZUF0KGJhc2UubGVuZ3RoIC0gMSkpKSB7XG4gICAgICBiYXNlID0gYmFzZS5zbGljZSgwLCAtMSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMudW5lc2NhcGUgPT09IHRydWUpIHtcbiAgICBpZiAoZ2xvYikgZ2xvYiA9IHV0aWxzLnJlbW92ZUJhY2tzbGFzaGVzKGdsb2IpO1xuXG4gICAgaWYgKGJhc2UgJiYgYmFja3NsYXNoZXMgPT09IHRydWUpIHtcbiAgICAgIGJhc2UgPSB1dGlscy5yZW1vdmVCYWNrc2xhc2hlcyhiYXNlKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBwcmVmaXgsXG4gICAgaW5wdXQsXG4gICAgc3RhcnQsXG4gICAgYmFzZSxcbiAgICBnbG9iLFxuICAgIGlzQnJhY2UsXG4gICAgaXNCcmFja2V0LFxuICAgIGlzR2xvYixcbiAgICBpc0V4dGdsb2IsXG4gICAgaXNHbG9ic3RhcixcbiAgICBuZWdhdGVkLFxuICAgIG5lZ2F0ZWRFeHRnbG9iXG4gIH07XG5cbiAgaWYgKG9wdHMudG9rZW5zID09PSB0cnVlKSB7XG4gICAgc3RhdGUubWF4RGVwdGggPSAwO1xuICAgIGlmICghaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XG4gICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgfVxuICAgIHN0YXRlLnRva2VucyA9IHRva2VucztcbiAgfVxuXG4gIGlmIChvcHRzLnBhcnRzID09PSB0cnVlIHx8IG9wdHMudG9rZW5zID09PSB0cnVlKSB7XG4gICAgbGV0IHByZXZJbmRleDtcblxuICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNsYXNoZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgY29uc3QgbiA9IHByZXZJbmRleCA/IHByZXZJbmRleCArIDEgOiBzdGFydDtcbiAgICAgIGNvbnN0IGkgPSBzbGFzaGVzW2lkeF07XG4gICAgICBjb25zdCB2YWx1ZSA9IGlucHV0LnNsaWNlKG4sIGkpO1xuICAgICAgaWYgKG9wdHMudG9rZW5zKSB7XG4gICAgICAgIGlmIChpZHggPT09IDAgJiYgc3RhcnQgIT09IDApIHtcbiAgICAgICAgICB0b2tlbnNbaWR4XS5pc1ByZWZpeCA9IHRydWU7XG4gICAgICAgICAgdG9rZW5zW2lkeF0udmFsdWUgPSBwcmVmaXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zW2lkeF0udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkZXB0aCh0b2tlbnNbaWR4XSk7XG4gICAgICAgIHN0YXRlLm1heERlcHRoICs9IHRva2Vuc1tpZHhdLmRlcHRoO1xuICAgICAgfVxuICAgICAgaWYgKGlkeCAhPT0gMCB8fCB2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgcGFydHMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBwcmV2SW5kZXggPSBpO1xuICAgIH1cblxuICAgIGlmIChwcmV2SW5kZXggJiYgcHJldkluZGV4ICsgMSA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBpbnB1dC5zbGljZShwcmV2SW5kZXggKyAxKTtcbiAgICAgIHBhcnRzLnB1c2godmFsdWUpO1xuXG4gICAgICBpZiAob3B0cy50b2tlbnMpIHtcbiAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBkZXB0aCh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgc3RhdGUubWF4RGVwdGggKz0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS5kZXB0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5zbGFzaGVzID0gc2xhc2hlcztcbiAgICBzdGF0ZS5wYXJ0cyA9IHBhcnRzO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzY2FuO1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsIkNIQVJfQVNURVJJU0siLCJDSEFSX0FUIiwiQ0hBUl9CQUNLV0FSRF9TTEFTSCIsIkNIQVJfQ09NTUEiLCJDSEFSX0RPVCIsIkNIQVJfRVhDTEFNQVRJT05fTUFSSyIsIkNIQVJfRk9SV0FSRF9TTEFTSCIsIkNIQVJfTEVGVF9DVVJMWV9CUkFDRSIsIkNIQVJfTEVGVF9QQVJFTlRIRVNFUyIsIkNIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCIsIkNIQVJfUExVUyIsIkNIQVJfUVVFU1RJT05fTUFSSyIsIkNIQVJfUklHSFRfQ1VSTFlfQlJBQ0UiLCJDSEFSX1JJR0hUX1BBUkVOVEhFU0VTIiwiQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCIsImlzUGF0aFNlcGFyYXRvciIsImNvZGUiLCJkZXB0aCIsInRva2VuIiwiaXNQcmVmaXgiLCJpc0dsb2JzdGFyIiwiSW5maW5pdHkiLCJzY2FuIiwiaW5wdXQiLCJvcHRpb25zIiwib3B0cyIsImxlbmd0aCIsInNjYW5Ub0VuZCIsInBhcnRzIiwic2xhc2hlcyIsInRva2VucyIsInN0ciIsImluZGV4Iiwic3RhcnQiLCJsYXN0SW5kZXgiLCJpc0JyYWNlIiwiaXNCcmFja2V0IiwiaXNHbG9iIiwiaXNFeHRnbG9iIiwiYnJhY2VFc2NhcGVkIiwiYmFja3NsYXNoZXMiLCJuZWdhdGVkIiwibmVnYXRlZEV4dGdsb2IiLCJmaW5pc2hlZCIsImJyYWNlcyIsInByZXYiLCJ2YWx1ZSIsImVvcyIsInBlZWsiLCJjaGFyQ29kZUF0IiwiYWR2YW5jZSIsIm5leHQiLCJwdXNoIiwibm9leHQiLCJpc0V4dGdsb2JDaGFyIiwibm9uZWdhdGUiLCJub3BhcmVuIiwiYmFzZSIsInByZWZpeCIsImdsb2IiLCJzbGljZSIsInVuZXNjYXBlIiwicmVtb3ZlQmFja3NsYXNoZXMiLCJzdGF0ZSIsIm1heERlcHRoIiwicHJldkluZGV4IiwiaWR4IiwibiIsImkiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst path = __webpack_require__(/*! path */ \"path\");\nconst win32 = process.platform === \"win32\";\nconst { REGEX_BACKSLASH, REGEX_REMOVE_BACKSLASH, REGEX_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_GLOBAL } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js\");\nexports.isObject = (val)=>val !== null && typeof val === \"object\" && !Array.isArray(val);\nexports.hasRegexChars = (str)=>REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = (str)=>str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = (str)=>str.replace(REGEX_SPECIAL_CHARS_GLOBAL, \"\\\\$1\");\nexports.toPosixSlashes = (str)=>str.replace(REGEX_BACKSLASH, \"/\");\nexports.removeBackslashes = (str)=>{\n    return str.replace(REGEX_REMOVE_BACKSLASH, (match)=>{\n        return match === \"\\\\\" ? \"\" : match;\n    });\n};\nexports.supportsLookbehinds = ()=>{\n    const segs = process.version.slice(1).split(\".\").map(Number);\n    if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {\n        return true;\n    }\n    return false;\n};\nexports.isWindows = (options)=>{\n    if (options && typeof options.windows === \"boolean\") {\n        return options.windows;\n    }\n    return win32 === true || path.sep === \"\\\\\";\n};\nexports.escapeLast = (input, char, lastIdx)=>{\n    const idx = input.lastIndexOf(char, lastIdx);\n    if (idx === -1) return input;\n    if (input[idx - 1] === \"\\\\\") return exports.escapeLast(input, char, idx - 1);\n    return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\nexports.removePrefix = (input, state = {})=>{\n    let output = input;\n    if (output.startsWith(\"./\")) {\n        output = output.slice(2);\n        state.prefix = \"./\";\n    }\n    return output;\n};\nexports.wrapOutput = (input, state = {}, options = {})=>{\n    const prepend = options.contains ? \"\" : \"^\";\n    const append = options.contains ? \"\" : \"$\";\n    let output = `${prepend}(?:${input})${append}`;\n    if (state.negated === true) {\n        output = `(?:^(?!${output}).*$)`;\n    }\n    return output;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vcGljb21hdGNoQDIuMy4xL25vZGVfbW9kdWxlcy9waWNvbWF0Y2gvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsT0FBT0MsbUJBQU9BLENBQUM7QUFDckIsTUFBTUMsUUFBUUMsUUFBUUMsUUFBUSxLQUFLO0FBQ25DLE1BQU0sRUFDSkMsZUFBZSxFQUNmQyxzQkFBc0IsRUFDdEJDLG1CQUFtQixFQUNuQkMsMEJBQTBCLEVBQzNCLEdBQUdQLG1CQUFPQSxDQUFDO0FBRVpRLGdCQUFnQixHQUFHRSxDQUFBQSxNQUFPQSxRQUFRLFFBQVEsT0FBT0EsUUFBUSxZQUFZLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0Y7QUFDcEZGLHFCQUFxQixHQUFHTSxDQUFBQSxNQUFPUixvQkFBb0JTLElBQUksQ0FBQ0Q7QUFDeEROLG1CQUFtQixHQUFHTSxDQUFBQSxNQUFPQSxJQUFJRyxNQUFNLEtBQUssS0FBS1QsUUFBUUssYUFBYSxDQUFDQztBQUN2RU4sbUJBQW1CLEdBQUdNLENBQUFBLE1BQU9BLElBQUlLLE9BQU8sQ0FBQ1osNEJBQTRCO0FBQ3JFQyxzQkFBc0IsR0FBR00sQ0FBQUEsTUFBT0EsSUFBSUssT0FBTyxDQUFDZixpQkFBaUI7QUFFN0RJLHlCQUF5QixHQUFHTSxDQUFBQTtJQUMxQixPQUFPQSxJQUFJSyxPQUFPLENBQUNkLHdCQUF3QmlCLENBQUFBO1FBQ3pDLE9BQU9BLFVBQVUsT0FBTyxLQUFLQTtJQUMvQjtBQUNGO0FBRUFkLDJCQUEyQixHQUFHO0lBQzVCLE1BQU1nQixPQUFPdEIsUUFBUXVCLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDLEdBQUdDLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUNDO0lBQ3JELElBQUlMLEtBQUtQLE1BQU0sS0FBSyxLQUFLTyxJQUFJLENBQUMsRUFBRSxJQUFJLEtBQU1BLElBQUksQ0FBQyxFQUFFLEtBQUssS0FBS0EsSUFBSSxDQUFDLEVBQUUsSUFBSSxJQUFLO1FBQ3pFLE9BQU87SUFDVDtJQUNBLE9BQU87QUFDVDtBQUVBaEIsaUJBQWlCLEdBQUd1QixDQUFBQTtJQUNsQixJQUFJQSxXQUFXLE9BQU9BLFFBQVFDLE9BQU8sS0FBSyxXQUFXO1FBQ25ELE9BQU9ELFFBQVFDLE9BQU87SUFDeEI7SUFDQSxPQUFPL0IsVUFBVSxRQUFRRixLQUFLa0MsR0FBRyxLQUFLO0FBQ3hDO0FBRUF6QixrQkFBa0IsR0FBRyxDQUFDMkIsT0FBT0MsTUFBTUM7SUFDakMsTUFBTUMsTUFBTUgsTUFBTUksV0FBVyxDQUFDSCxNQUFNQztJQUNwQyxJQUFJQyxRQUFRLENBQUMsR0FBRyxPQUFPSDtJQUN2QixJQUFJQSxLQUFLLENBQUNHLE1BQU0sRUFBRSxLQUFLLE1BQU0sT0FBTzlCLFFBQVEwQixVQUFVLENBQUNDLE9BQU9DLE1BQU1FLE1BQU07SUFDMUUsT0FBTyxDQUFDLEVBQUVILE1BQU1ULEtBQUssQ0FBQyxHQUFHWSxLQUFLLEVBQUUsRUFBRUgsTUFBTVQsS0FBSyxDQUFDWSxLQUFLLENBQUM7QUFDdEQ7QUFFQTlCLG9CQUFvQixHQUFHLENBQUMyQixPQUFPTSxRQUFRLENBQUMsQ0FBQztJQUN2QyxJQUFJQyxTQUFTUDtJQUNiLElBQUlPLE9BQU9DLFVBQVUsQ0FBQyxPQUFPO1FBQzNCRCxTQUFTQSxPQUFPaEIsS0FBSyxDQUFDO1FBQ3RCZSxNQUFNRyxNQUFNLEdBQUc7SUFDakI7SUFDQSxPQUFPRjtBQUNUO0FBRUFsQyxrQkFBa0IsR0FBRyxDQUFDMkIsT0FBT00sUUFBUSxDQUFDLENBQUMsRUFBRVYsVUFBVSxDQUFDLENBQUM7SUFDbkQsTUFBTWUsVUFBVWYsUUFBUWdCLFFBQVEsR0FBRyxLQUFLO0lBQ3hDLE1BQU1DLFNBQVNqQixRQUFRZ0IsUUFBUSxHQUFHLEtBQUs7SUFFdkMsSUFBSUwsU0FBUyxDQUFDLEVBQUVJLFFBQVEsR0FBRyxFQUFFWCxNQUFNLENBQUMsRUFBRWEsT0FBTyxDQUFDO0lBQzlDLElBQUlQLE1BQU1RLE9BQU8sS0FBSyxNQUFNO1FBQzFCUCxTQUFTLENBQUMsT0FBTyxFQUFFQSxPQUFPLEtBQUssQ0FBQztJQUNsQztJQUNBLE9BQU9BO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90YWlsd2luZHVpLXN0dWRpby8uL25vZGVfbW9kdWxlcy8ucG5wbS9waWNvbWF0Y2hAMi4zLjEvbm9kZV9tb2R1bGVzL3BpY29tYXRjaC9saWIvdXRpbHMuanM/MTEwYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCB3aW4zMiA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMic7XG5jb25zdCB7XG4gIFJFR0VYX0JBQ0tTTEFTSCxcbiAgUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSCxcbiAgUkVHRVhfU1BFQ0lBTF9DSEFSUyxcbiAgUkVHRVhfU1BFQ0lBTF9DSEFSU19HTE9CQUxcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5leHBvcnRzLmlzT2JqZWN0ID0gdmFsID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWwpO1xuZXhwb3J0cy5oYXNSZWdleENoYXJzID0gc3RyID0+IFJFR0VYX1NQRUNJQUxfQ0hBUlMudGVzdChzdHIpO1xuZXhwb3J0cy5pc1JlZ2V4Q2hhciA9IHN0ciA9PiBzdHIubGVuZ3RoID09PSAxICYmIGV4cG9ydHMuaGFzUmVnZXhDaGFycyhzdHIpO1xuZXhwb3J0cy5lc2NhcGVSZWdleCA9IHN0ciA9PiBzdHIucmVwbGFjZShSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTCwgJ1xcXFwkMScpO1xuZXhwb3J0cy50b1Bvc2l4U2xhc2hlcyA9IHN0ciA9PiBzdHIucmVwbGFjZShSRUdFWF9CQUNLU0xBU0gsICcvJyk7XG5cbmV4cG9ydHMucmVtb3ZlQmFja3NsYXNoZXMgPSBzdHIgPT4ge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSCwgbWF0Y2ggPT4ge1xuICAgIHJldHVybiBtYXRjaCA9PT0gJ1xcXFwnID8gJycgOiBtYXRjaDtcbiAgfSk7XG59O1xuXG5leHBvcnRzLnN1cHBvcnRzTG9va2JlaGluZHMgPSAoKSA9PiB7XG4gIGNvbnN0IHNlZ3MgPSBwcm9jZXNzLnZlcnNpb24uc2xpY2UoMSkuc3BsaXQoJy4nKS5tYXAoTnVtYmVyKTtcbiAgaWYgKHNlZ3MubGVuZ3RoID09PSAzICYmIHNlZ3NbMF0gPj0gOSB8fCAoc2Vnc1swXSA9PT0gOCAmJiBzZWdzWzFdID49IDEwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydHMuaXNXaW5kb3dzID0gb3B0aW9ucyA9PiB7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLndpbmRvd3MgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBvcHRpb25zLndpbmRvd3M7XG4gIH1cbiAgcmV0dXJuIHdpbjMyID09PSB0cnVlIHx8IHBhdGguc2VwID09PSAnXFxcXCc7XG59O1xuXG5leHBvcnRzLmVzY2FwZUxhc3QgPSAoaW5wdXQsIGNoYXIsIGxhc3RJZHgpID0+IHtcbiAgY29uc3QgaWR4ID0gaW5wdXQubGFzdEluZGV4T2YoY2hhciwgbGFzdElkeCk7XG4gIGlmIChpZHggPT09IC0xKSByZXR1cm4gaW5wdXQ7XG4gIGlmIChpbnB1dFtpZHggLSAxXSA9PT0gJ1xcXFwnKSByZXR1cm4gZXhwb3J0cy5lc2NhcGVMYXN0KGlucHV0LCBjaGFyLCBpZHggLSAxKTtcbiAgcmV0dXJuIGAke2lucHV0LnNsaWNlKDAsIGlkeCl9XFxcXCR7aW5wdXQuc2xpY2UoaWR4KX1gO1xufTtcblxuZXhwb3J0cy5yZW1vdmVQcmVmaXggPSAoaW5wdXQsIHN0YXRlID0ge30pID0+IHtcbiAgbGV0IG91dHB1dCA9IGlucHV0O1xuICBpZiAob3V0cHV0LnN0YXJ0c1dpdGgoJy4vJykpIHtcbiAgICBvdXRwdXQgPSBvdXRwdXQuc2xpY2UoMik7XG4gICAgc3RhdGUucHJlZml4ID0gJy4vJztcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuZXhwb3J0cy53cmFwT3V0cHV0ID0gKGlucHV0LCBzdGF0ZSA9IHt9LCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgcHJlcGVuZCA9IG9wdGlvbnMuY29udGFpbnMgPyAnJyA6ICdeJztcbiAgY29uc3QgYXBwZW5kID0gb3B0aW9ucy5jb250YWlucyA/ICcnIDogJyQnO1xuXG4gIGxldCBvdXRwdXQgPSBgJHtwcmVwZW5kfSg/OiR7aW5wdXR9KSR7YXBwZW5kfWA7XG4gIGlmIChzdGF0ZS5uZWdhdGVkID09PSB0cnVlKSB7XG4gICAgb3V0cHV0ID0gYCg/Ol4oPyEke291dHB1dH0pLiokKWA7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn07XG4iXSwibmFtZXMiOlsicGF0aCIsInJlcXVpcmUiLCJ3aW4zMiIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsIlJFR0VYX0JBQ0tTTEFTSCIsIlJFR0VYX1JFTU9WRV9CQUNLU0xBU0giLCJSRUdFWF9TUEVDSUFMX0NIQVJTIiwiUkVHRVhfU1BFQ0lBTF9DSEFSU19HTE9CQUwiLCJleHBvcnRzIiwiaXNPYmplY3QiLCJ2YWwiLCJBcnJheSIsImlzQXJyYXkiLCJoYXNSZWdleENoYXJzIiwic3RyIiwidGVzdCIsImlzUmVnZXhDaGFyIiwibGVuZ3RoIiwiZXNjYXBlUmVnZXgiLCJyZXBsYWNlIiwidG9Qb3NpeFNsYXNoZXMiLCJyZW1vdmVCYWNrc2xhc2hlcyIsIm1hdGNoIiwic3VwcG9ydHNMb29rYmVoaW5kcyIsInNlZ3MiLCJ2ZXJzaW9uIiwic2xpY2UiLCJzcGxpdCIsIm1hcCIsIk51bWJlciIsImlzV2luZG93cyIsIm9wdGlvbnMiLCJ3aW5kb3dzIiwic2VwIiwiZXNjYXBlTGFzdCIsImlucHV0IiwiY2hhciIsImxhc3RJZHgiLCJpZHgiLCJsYXN0SW5kZXhPZiIsInJlbW92ZVByZWZpeCIsInN0YXRlIiwib3V0cHV0Iiwic3RhcnRzV2l0aCIsInByZWZpeCIsIndyYXBPdXRwdXQiLCJwcmVwZW5kIiwiY29udGFpbnMiLCJhcHBlbmQiLCJuZWdhdGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js\n");

/***/ })

};
;